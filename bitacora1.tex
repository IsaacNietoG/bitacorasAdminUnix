% Created 2026-02-18 Wed 19:24
% Intended LaTeX compiler: pdflatex
\documentclass[11pt, letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[margin=2.5cm]{geometry}      % Márgenes decentes
\usepackage[utf8]{inputenc}
\usepackage{palatino}                   % Tipografía elegante
\usepackage{xcolor}                     % Colores personalizados
\author{Equipo Alpine White}
\date{\textit{{[}2026-02-09 Mon]}}
\title{Bitácora Semanal: Administración de Sistemas Unix Bitácora Semanal - Administración de Unix}
\hypersetup{
 pdfauthor={Equipo Alpine White},
 pdftitle={Bitácora Semanal: Administración de Sistemas Unix Bitácora Semanal - Administración de Unix},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 30.2 (Org mode 9.7.39)}, 
 pdflang={English}}
\begin{document}

\maketitle
\setcounter{tocdepth}{2}
\tableofcontents

\section{Información General}
\label{sec:org7cead81}
\begin{itemize}
\item \textbf{Semana:} Del 3 de Febrero 2026 al 6 de Febrero 2026
\item \textbf{Equipo:}
\begin{itemize}
\item Arreguín Salgado Gael Emiliano
\item Gramer Muñoz Omar Fernando
\item López Pérez Mariana
\item Nieto Gallegos Isaac Julián
\end{itemize}
\end{itemize}
\section{Sesión 1: 3 de Febrero 2026}
\label{sec:org60b8bfc}

Esta sesión fue una introducción general a la clase y a conceptos iniciales de Linux.
\subsection{Conceptos nuevos}
\label{sec:org01e0598}

\begin{itemize}
\item \textbf{GRUB (bootloader):} GRUB (GNU GRand Unified Bootloader) es un \textbf{cargador de arranque}; es el programa que aparece al iniciar y se encarga de cargar el sistema operativo (o una ISO) y pasarle el control.
\begin{itemize}
\item \textbf{Ventoy y su GRUB:} Ventoy no usa exactamente el mismo GRUB que el del sistema instalado; incluye y arranca con su propia varainte de \textbf{GRUB2} para poder gestionar el menú y el arranque de múltiples ISOs desde una sola USB.
\item \textbf{Consola de GRUB en Ventoy:} En el menú de Ventoy/GRUB, al presionar la tecla \texttt{C} se abre la \textbf{consola} (tipo terminal) de GRUB.
\begin{itemize}
\item En esta consola podemos inspeccionar y explorar qué ve el bootloader (discos/particiones/archivos) y consultar variables o configuración.
\item Comandos:
\begin{verbatim}
      ls
      help
      set
      ls (hd0,gpt1)/
      cat (hd0,gpt1)/boot/grub/grub.cfg
\end{verbatim}
\item Esto sirve para tipo depurar, inspeccionar por qué algo no arranca como debe, confirmar rutas, o entender cómo Ventoy/GRUB está resolviendo la configuración.
\end{itemize}
\end{itemize}

\item El comando ls nos permite listar los contenidos del directorio en el que nos encontramos actualmente. Usando los parámetros -la, podemos colocarlos en forma de lista y mostrar archivos ocultos para tener una vista más general y completa del directorio. Por ejemplo:
\end{itemize}

\begin{verbatim}
ls -la
\end{verbatim}

\phantomsection
\label{}
\begin{verbatim}
total 456
drwxr-xr-x 1 marlop18 marlop18    132 Feb 18 19:22 .
drwxr-xr-x 1 marlop18 marlop18     44 Feb 10 09:22 ..
-rw-r--r-- 1 marlop18 marlop18  28160 Feb 18 19:20 bitacora1.org
-rw-r--r-- 1 marlop18 marlop18 259064 Feb 18 19:22 bitacora1.pdf
-rw-r--r-- 1 marlop18 marlop18  35070 Feb 18 19:22 bitacora1.tex
drwxr-xr-x 1 marlop18 marlop18    142 Feb 18 19:24 .git
-rw-r--r-- 1 marlop18 marlop18     25 Feb 18 19:22 test.txt
-rw-r--r-- 1 marlop18 marlop18 133687 Feb 10 09:22 ventoy_boot.jpg
\end{verbatim}


\begin{itemize}
\item Ventoy es una herramienta que nos permite poder arrancar varias imágenes ISO desde una misma memoria USB. Se instala sobre la memoria USB, y recursivamente busca las imágenes ISO que contenga para mostrarlas en el menú de arranque. Se nos queda de tarea para la próxima semana traer una memoria USB con Ventoy instalado.

\begin{center}
\includegraphics[width=.9\linewidth]{./ventoy_boot.jpg}
\end{center}

\item Existen dos formas de referenciar un archivo en Linux: Mediante su ruta relativa y mediante su ruta absoluta. Generalmente una ruta relativa empieza por un ./ o ../, mientras que una ruta absoluta empieza por /, ya que es la ruta completa al archivo desde la raíz del sistema de archivos. Por ejemplo:
\end{itemize}

\begin{verbatim}
echo este es el mismo archivo > test.txt
cat /home/mrtaichi/Documents/escuela/adminUnix/test.txt # Ruta absoluta
cat ./test.txt # Ruta relativa
\end{verbatim}

\phantomsection
\label{}
\begin{verbatim}
este es el mismo archivo
\end{verbatim}


\begin{itemize}
\item LAN? (en proceso)

\item En Linux, \ref{sec:orgb8c669d}. Esto incluye a los dispositivos, ya que la carpeta /dev guarda representaciones en archivo de todos los dispositivos que están conectados a la computadora. Esto incluye desde los mismos dispositivos de almacenamiento, hasta cosas más ``virtuales'' como las terminales y pseudoterminales del sistema.

\item Dispositivo psar? (en proceso)

\item Gparted es una herramienta con interfaz gráfica para crear y modificar particiones en un disco.
\end{itemize}
\subsection{Conceptos de repaso}
\label{sec:orga718d80}

\begin{itemize}
\item \textbf{Proceso de arranque (boot process):}
Secuencia general: BIOS/UEFI → bootloader (GRUB) → kernel → init/systemd.
Punto clave: el sistema operativo \textbf{no existe} mientras estamos en GRUB; solo existe firmware con bootloader.

\item \textbf{Bootloader vs Kernel:}
GRUB no es el sistema operativo ni el kernel.
Su única responsabilidad es localizar, cargar el kernel (y el initramfs) en memoria y cederle el control.
No ejecuta procesos ni gestiona recursos del sistema.

\item \textbf{Separación de responsabilidades:}
Ventoy delega completamente el arranque a GRUB y evita modificar el disco.
Ejemplo de buen diseño: cada componente hace una sola cosa bien definida.

\item \textbf{Acceso a disco antes del kernel:}
GRUB puede leer sistemas de archivos (FAT, EXT, ISO) sin drivers del kernel.

\item \textbf{Lectura de archivos sin montaje:}
El bootloader accede directamente a estructuras del sistema de archivos.
Montar un FS es una abstracción que pertenece al kernel, no al bootloader.
\end{itemize}
\subsection{Máximas}
\label{sec:orgef19202}

\subsubsection{Todo es un archivo}
\label{sec:orgb8c669d}
En los sistemas derivados de Unix, como Linux
\subsection{Sección libre}
\label{sec:org041bc37}
\section{Sesión 2: 4 de Febrero 2026}
\label{sec:org851a998}

\subsection{Conceptos nuevos}
\label{sec:org58c030d}

\begin{itemize}
\item Estuvimos hablando de la importancia de la redundancia para preservar la información. Como ejemplo usamos el sistema RAID, que utiliza varios discos duros para crear replicación de información y tolerancia a fallos.

\item La necesidad principal de tener redundancia en la información es para no tener un sólo punto de falla en nuestros sistemas que pueda fallar. Si alguna parte de nuestro sistema falla, siempre existe otro componente listo para tomar el lugar y mantener el sistema funcionando.

\item Generalmente la emulación es más lenta que la virtualización. El primer sistema de WSL usaba emulación de Linux, ahora el segundo utiliza virtualización.

\item El propósito de que cada quien utilice una distribución distinta es demostrar la máxima: ``\ref{sec:orgaa715c1}''. Vamos a observar como -en esencia- todos las distribuciones de Linux tienen tantas cosas en común que podemos hacer cualquier cosa en cualquier distro.

\item Distrowatch es un sitio web en el que se pueden observar todas las distribuciones de Linux y muchos datos acerca de ellas. Lo que resulta interesante es que incluso un ranking de cuáles son las distros más usadas hasta el mometo.

\item SCSI (que se pronuncia ``scuzzy'') es una interfaz de intercambio de datos que se utiliza sobre todo en servidores y computadoras de alto desempeño. Hablando del sistema RAID, es generalmente sobre esta interfaz sobre la que se construyen varios controladores RAID que están en la industria.
\end{itemize}
\subsection{Conceptos de repaso}
\label{sec:orgec594c3}

\subsection{Máximas}
\label{sec:orgd71cdcb}
\subsubsection{Todos los Linux son iguales}
\label{sec:orgaa715c1}
En cualquier distribución de Linux podemos -a final de cuentas- hacer cualquier cosa. Todas funcionan esencialmente para lo mismo, y aunque evidentemente hay diferencias, se puede trabajar con ellas sin problema.
\subsection{Sección libre}
\label{sec:orge27192e}
\section{Sesión 3: 5 de Febrero 2026}
\label{sec:org061a00f}

\subsection{Conceptos nuevos}
\label{sec:org868f038}

\begin{itemize}
\item Unix nace en 1969 como un sistema operativo desarrollado en Bell Labs, al principio con fines académicos y distribuido para varias universidades. De ahí nace BSD cuando se vuelve comercial

\item Y de ahí también nace Linux, como un kernel Unix-like desarrollado en 1991 por Linus Torvalds, el cual se termina fusionando con GNU para formar un sistema operativo completo.

\item Un proceso es un programa que se está ejecutando en el sistema y constantemente le está pidiendo recursos al kernel. Los procesos se comunican con el kernel a través de syscalls
\end{itemize}
\subsection{Conceptos de repaso}
\label{sec:org24664ce}

\subsection{Máximas}
\label{sec:org77ddf2f}

\subsection{Sección libre}
\label{sec:orgedb919c}

Para entender mejor el funcionamiento de un proceso, se me ocurrió meterme al código fuente de Linux y, con ayuda de la IA, aprender acerca de la estructura que conforma un proceso como tal.

Primero había que ubicarla, y después de indagar un rato en la documentación me pude dar cuenta de que el término usado en el kernel para referirse a los procesos es una task (o tarea). Esto debido a que esta estructura sirve tanto para procesos de programas como para los hilos de un mismo programa. La estructura que buscamos es entonces task\textsubscript{struc}, la cual se encuentra declarada en include/linux/sched.h

Como el código que define esta estructura es muy extenso, es aquí donde me tuve que servir de la IA para entenderle. Le pasé el archivo y le pedí una explicación sobre cada uno de los componentes de esta estructura. Este fue el resultado:

\begin{quote}
Entiendo perfectamente, la `struct task\textsubscript{struct}` es intimidante porque es el ``corazón'' de Linux y contiene prácticamente todo lo que el kernel sabe sobre un proceso. Basado en el archivo `sched.h` que compartiste, vamos a despedazarla en partes lógicas para que sea más fácil de digerir.

Piensa en la `task\textsubscript{struct}` como el \textbf{\textbf{expediente completo}} de una persona en una oficina gubernamental; tiene su nombre, su familia, su dinero, sus propiedades y qué está haciendo en este momento.

\#\#\# 1. Estado y Propósito (¿Qué está haciendo?)

Lo primero que el kernel necesita saber es si el proceso puede correr o si está esperando algo.

\textbf{\textbf{*`\_\textsubscript{state}`}}: Define si el proceso está `TASK\textsubscript{RUNNING}` (listo para usar la CPU), `TASK\textsubscript{INTERRUPTIBLE}` (durmiendo pero puede despertar con una señal) o en otros estados como `TASK\textsubscript{DEAD}`.
\textbf{\textbf{*`stack`}}: Un puntero al stack del kernel para este proceso específico.
\textbf{\textbf{*`flags`}}: Banderas que indican atributos especiales (por ejemplo, si es un hilo del kernel o si está saliendo).

\#\#\# 2. Identificación (¿Quién es?)

\textbf{\textbf{*`pid`}}: El \textbf{Process ID} único que ves cuando usas comandos como `top`.
\textbf{\textbf{*`tgid`}}: El \textbf{Thread Group ID}. En Linux, para el hilo principal, el PID y el TGID son iguales. Si creas más hilos en ese proceso, todos compartirán el mismo TGID pero tendrán PIDs distintos.
\textbf{\textbf{*`comm[TASK\textsubscript{COMM}\textsubscript{LEN}]`}}: El nombre del ejecutable (máximo 16 caracteres).

\#\#\# 3. El Planificador (¿Cuándo le toca la CPU?)

Esta sección decide la prioridad del proceso.

***`prio`, `static\textsubscript{prio}`, `normal\textsubscript{prio}**`: Las distintas prioridades que el planificador usa para decidir a quién darle la CPU.
***`se`, `rt`, `dl**`: Estas son sub-estructuras (`sched\textsubscript{entity}`, `sched\textsubscript{rt}\textsubscript{entity}`, etc.) que contienen los datos específicos para diferentes tipos de procesos (normales, de tiempo real, etc.).

\#\#\# 4. Relaciones Familiares (¿Quién lo creó?)

Linux organiza los procesos en un árbol genealógico.

\textbf{\textbf{*`parent`}}: Puntero al proceso padre.
\textbf{\textbf{*`children`}}: Una lista de todos los procesos hijos que este proceso ha creado.
\textbf{\textbf{*`sibling`}}: Enlaces a sus ``hermanos'' (otros procesos creados por el mismo padre).

\#\#\# 5. Recursos (¿Qué posee?)

Aquí es donde la estructura se conecta con el resto del sistema.

\textbf{\textbf{*`mm`}}: Puntero a `struct mm\textsubscript{struct}`. Aquí reside toda la información de la \textbf{\textbf{memoria virtual}} del proceso (sus páginas, segmentos, etc.).
\textbf{\textbf{*`files`}}: Puntero a `struct files\textsubscript{struct}`. Es la tabla que guarda todos los \textbf{\textbf{archivos abiertos}} (tus descriptores de archivo 0, 1, 2, etc.).
\textbf{\textbf{*`fs`}}: Información del sistema de archivos, como el directorio actual (`pwd`).
\textbf{\textbf{*`cred`}}: Las credenciales de seguridad (quién es el dueño: UID, GID).

\#\#\# 6. Señales (¿Qué le han dicho?)

\textbf{\textbf{*`signal`}} y \textbf{\textbf{`sighand`}}: Manejan qué debe hacer el proceso cuando recibe señales como un `SIGKILL` o `SIGTERM`.
\textbf{\textbf{*`pending`}}: Una lista de señales que han llegado pero que el proceso aún no ha procesado.

\textbf{\textbf{Resumen rápido para no volverse loco:}}
Si estás programando en el kernel y tienes un puntero a un proceso (usualmente llamado `p` o `current`), lo más común es que solo te interesen `p->pid`, `p->comm`, `p->mm` (memoria) o `p->files` (archivos). El resto son detalles técnicos para que el kernel gestione la magia por debajo.

¿Hay alguna de estas secciones que te interese explorar más a fondo con el código que pasaste?
\end{quote}

De esto ya pude entender mejor cómo funciona el tema de los procesos en Linux y la relación de parentesco que debe existir entre todos ellos que los lleva al proceso inicial (systemd).
\section{Sesión 4: 6 de Febrero 2026}
\label{sec:orgf9f2822}

\subsection{Conceptos nuevos}
\label{sec:org161a0fb}

\begin{itemize}
\item Linux tiene un directorio llamado /tmp el cual es volátil. Ahí se guardan todos los archivos que se necesitan para el funcionamiento de los programas y SO durante la sesión, pero que no son necesarios de conservarse y por lo tanto se pueden borrar en el siguiente apagado. En Windows existe la misma implementación en una carpeta llamada Temp

\item nohup es un comando que nos permite ejecutar procesos y evitar que mueran cuando el padre muera.

\begin{verbatim}
man nohup
\end{verbatim}

\phantomsection
\label{}
\begin{verbatim}
  NOHUP(1)                         User Commands                         NOHUP(1)

  NAME
         nohup - run a command immune to hangups, with output to a non-tty

  SYNOPSIS
         nohup COMMAND [ARG]...
         nohup OPTION

  DESCRIPTION
         Run COMMAND, ignoring hangup signals.

         --help display this help and exit

         --version
                output version information and exit

         If  standard  input  is a terminal, redirect it from an unreadable file.
         If standard output is a terminal, append output to 'nohup.out' if possi‐
         ble, '$HOME/nohup.out' otherwise.  If  standard  error  is  a  terminal,
         redirect it to standard output.  To save output to FILE, use 'nohup COM‐
         MAND > FILE'.

         Your  shell  may have its own version of nohup, which usually supersedes
         the version described here.  Please refer to your shell's  documentation
         for details about the options it supports.

     Exit status:
         125    if the nohup command itself fails

         126    if COMMAND is found but cannot be invoked

         127    if COMMAND cannot be found

         -      the exit status of COMMAND otherwise

  AUTHOR
         Written by Jim Meyering.

  REPORTING BUGS
         Report bugs to: bug-coreutils@gnu.org
         GNU coreutils home page: <https://www.gnu.org/software/coreutils/>
         General help using GNU software: <https://www.gnu.org/gethelp/>
         Report any translation bugs to <https://translationproject.org/team/>

  COPYRIGHT
         Copyright © 2025 Free Software Foundation, Inc.  License GPLv3+: GNU GPL
         version 3 or later <https://gnu.org/licenses/gpl.html>.
         This  is  free  software:  you  are  free to change and redistribute it.
         There is NO WARRANTY, to the extent permitted by law.

  SEE ALSO
         Full documentation <https://www.gnu.org/software/coreutils/nohup>
         or available locally via: info '(coreutils) nohup invocation'

  GNU coreutils 9.9                November 2025                         NOHUP(1)
\end{verbatim}

\item Con el comando pstree podemos ver un árbol de los procesos en ejecución actualmente en nuestro sistema. Esto nos da una vista muy clara de las relaciones de parentesco de todos estos.
\end{itemize}

\begin{verbatim}
pstree
\end{verbatim}

\phantomsection
\label{}
\begin{verbatim}
systemd-+-ModemManager---3*[{ModemManager}]
        |-NetworkManager---3*[{NetworkManager}]
        |-accounts-daemon---3*[{accounts-daemon}]
        |-bluetoothd
        |-colord---3*[{colord}]
        |-containerd---13*[{containerd}]
        |-cupsd
        |-dbus-broker-lau---dbus-broker
        |-dirmngr
        |-dockerd---13*[{dockerd}]
        |-gdm-+-gdm-session-wor-+-gdm-wayland-ses-+-gnome-session-i---3*[{gnome-session-i}]
        |     |                 |                 `-3*[{gdm-wayland-ses}]
        |     |                 `-3*[{gdm-session-wor}]
        |     `-4*[{gdm}]
        |-geoclue---3*[{geoclue}]
        |-pamac-daemon---3*[{pamac-daemon}]
        |-polkitd---3*[{polkitd}]
        |-power-profiles----3*[{power-profiles-}]
        |-rtkit-daemon---2*[{rtkit-daemon}]
        |-systemd-+-(sd-pam)
        |         |-at-spi-bus-laun-+-dbus-broker-lau---dbus-broker
        |         |                 `-4*[{at-spi-bus-laun}]
        |         |-at-spi2-registr---3*[{at-spi2-registr}]
        |         |-chrome-+-2*[cat]
        |         |        |-chrome---chrome---24*[{chrome}]
        |         |        |-chrome---chrome-+-2*[chrome---7*[{chrome}]]
        |         |        |                 |-chrome---15*[{chrome}]
        |         |        |                 |-6*[chrome---13*[{chrome}]]
        |         |        |                 |-6*[chrome---14*[{chrome}]]
        |         |        |                 |-chrome---27*[{chrome}]
        |         |        |                 `-chrome---20*[{chrome}]
        |         |        |-chrome---12*[{chrome}]
        |         |        |-chrome---8*[{chrome}]
        |         |        `-38*[{chrome}]
        |         |-2*[chrome_crashpad---2*[{chrome_crashpad}]]
        |         |-chrome_crashpad---{chrome_crashpad}
        |         |-code-+-code---code---28*[{code}]
        |         |      |-code---code---code---12*[{code}]
        |         |      |-code---10*[{code}]
        |         |      |-code---15*[{code}]
        |         |      |-code---17*[{code}]
        |         |      |-code---16*[{code}]
        |         |      `-38*[{code}]
        |         |-dbus-broker-lau---dbus-broker
        |         |-dconf-service---3*[{dconf-service}]
        |         |-deja-dup---5*[{deja-dup}]
        |         |-deja-dup-monito---4*[{deja-dup-monito}]
        |         |-evolution-addre---6*[{evolution-addre}]
        |         |-evolution-alarm---7*[{evolution-alarm}]
        |         |-evolution-calen---9*[{evolution-calen}]
        |         |-evolution-sourc---4*[{evolution-sourc}]
        |         |-2*[gjs---11*[{gjs}]]
        |         |-gnome-calendar---7*[{gnome-calendar}]
        |         |-gnome-keyring-d---4*[{gnome-keyring-d}]
        |         |-gnome-session-c---{gnome-session-c}
        |         |-gnome-session-s---4*[{gnome-session-s}]
        |         |-gnome-shell-+-Xwayland---15*[{Xwayland}]
        |         |             |-bwrap---bwrap---glycin-image-rs---2*[{glycin-image-rs}]
        |         |             |-mutter-x11-fram---16*[{mutter-x11-fram}]
        |         |             `-34*[{gnome-shell}]
        |         |-gnome-shell-cal---6*[{gnome-shell-cal}]
        |         |-gnome-text-edit---11*[{gnome-text-edit}]
        |         |-goa-daemon---3*[{goa-daemon}]
        |         |-goa-identity-se---3*[{goa-identity-se}]
        |         |-gsd-a11y-settin---4*[{gsd-a11y-settin}]
        |         |-gsd-color---4*[{gsd-color}]
        |         |-gsd-datetime---4*[{gsd-datetime}]
        |         |-gsd-disk-utilit---3*[{gsd-disk-utilit}]
        |         |-gsd-housekeepin---4*[{gsd-housekeepin}]
        |         |-gsd-keyboard---4*[{gsd-keyboard}]
        |         |-gsd-media-keys---4*[{gsd-media-keys}]
        |         |-gsd-power---5*[{gsd-power}]
        |         |-gsd-print-notif---3*[{gsd-print-notif}]
        |         |-gsd-printer---3*[{gsd-printer}]
        |         |-gsd-rfkill---3*[{gsd-rfkill}]
        |         |-gsd-screensaver---3*[{gsd-screensaver}]
        |         |-gsd-sharing---4*[{gsd-sharing}]
        |         |-gsd-smartcard---4*[{gsd-smartcard}]
        |         |-gsd-sound---4*[{gsd-sound}]
        |         |-gsd-usb-protect---4*[{gsd-usb-protect}]
        |         |-gsd-wwan---4*[{gsd-wwan}]
        |         |-gsd-xsettings---4*[{gsd-xsettings}]
        |         |-gvfs-afc-volume---4*[{gvfs-afc-volume}]
        |         |-gvfs-goa-volume---3*[{gvfs-goa-volume}]
        |         |-gvfs-gphoto2-vo---3*[{gvfs-gphoto2-vo}]
        |         |-gvfs-mtp-volume---3*[{gvfs-mtp-volume}]
        |         |-gvfs-udisks2-vo---4*[{gvfs-udisks2-vo}]
        |         |-gvfsd-+-gvfsd-dnssd---3*[{gvfsd-dnssd}]
        |         |       |-gvfsd-network---4*[{gvfsd-network}]
        |         |       |-gvfsd-recent---3*[{gvfsd-recent}]
        |         |       |-gvfsd-trash---4*[{gvfsd-trash}]
        |         |       |-gvfsd-wsdd-+-python3
        |         |       |            `-3*[{gvfsd-wsdd}]
        |         |       `-3*[{gvfsd}]
        |         |-gvfsd-fuse---6*[{gvfsd-fuse}]
        |         |-gvfsd-metadata---3*[{gvfsd-metadata}]
        |         |-ibus-daemon-+-ibus-dconf---4*[{ibus-dconf}]
        |         |             |-ibus-engine-sim---3*[{ibus-engine-sim}]
        |         |             |-ibus-extension----5*[{ibus-extension-}]
        |         |             `-3*[{ibus-daemon}]
        |         |-ibus-portal---3*[{ibus-portal}]
        |         |-ibus-x11---10*[{ibus-x11}]
        |         |-keyboxd
        |         |-kgx-+-zsh---emacs-+-bash---pstree
        |         |     |             |-bwrap---bwrap---glycin-svg---2*[{glycin-svg}]
        |         |     |             `-8*[{emacs}]
        |         |     |-zsh
        |         |     `-10*[{kgx}]
        |         |-localsearch-3---7*[{localsearch-3}]
        |         |-nautilus---13*[{nautilus}]
        |         |-obexd
        |         |-pipewire---2*[{pipewire}]
        |         |-pipewire-pulse---2*[{pipewire-pulse}]
        |         |-wireplumber---5*[{wireplumber}]
        |         |-xdg-desktop-por---6*[{xdg-desktop-por}]
        |         |-2*[xdg-desktop-por---5*[{xdg-desktop-por}]]
        |         |-xdg-document-po-+-fusermount3
        |         |                 `-6*[{xdg-document-po}]
        |         |-xdg-permission----3*[{xdg-permission-}]
        |         |-2*[zsh---gitstatusd---16*[{gitstatusd}]]
        |         `-4*[zsh]
        |-systemd-journal
        |-systemd-logind
        |-systemd-machine
        |-systemd-timesyn---{systemd-timesyn}
        |-systemd-udevd
        |-systemd-userdbd---3*[systemd-userwor]
        |-udisksd---6*[{udisksd}]
        |-upowerd---3*[{upowerd}]
        `-wpa_supplicant
\end{verbatim}

\begin{itemize}
\item De aquí podemos observar una vez más como el proceso más importante y del que nacen todos los procesos en espacio de usuario es el proceso systemd. Además, observamos algunas cosillas interesantes como los procesos que generan nuestro entorno de escritorio, pipewire para el sonido, etc.
\end{itemize}
\subsection{Conceptos de repaso}
\label{sec:orgc0acc47}

\begin{itemize}
\item Me parece que nohup ya había sido visto?
\end{itemize}
\subsection{Máximas}
\label{sec:org8992b05}

\subsection{Sección libre}
\label{sec:orgb7f6c57}

\begin{itemize}
\item \textbf{Semana:} Del 9 de Febero al 13 de Febrero 2026
\end{itemize}


Durante la semana vimos una variedad de comandos que nos permiten ver la configuración que hay dentro de bas
\section{Comandos de Administración en Linux}
\label{sec:org31320e6}

Definiciones de Comandos de Administración en Linux

\begin{center}
\begin{tabular}{ll}
Comando & Definición\\
\hline
dmesg $\backslash$ & less & Muestra el registro del kernel (mensajes del sistema), incluyendo detección de hardware, particiones, errores de disco y eventos al arrancar. El uso de `less` permite navegar el historial página por página.\\
fdisk -l /dev/sdf & Lista la tabla de particiones del disco especificado. Muestra tamaño, tipo (EFI, Linux, HPFS/NTFS), sectores y UUID. Es útil para identificar cómo está organizada la memoria o el disco.\\
p (en fdisk) & Dentro del intérprete interactivo de fdisk, el comando `p` imprime (print) la tabla actual de particiones.\\
n (en fdisk) & Crea una nueva partición dentro del disco seleccionado. Permite elegir tipo (primaria, extendida) y tamaño.\\
gpart & Herramienta para analizar y recuperar tablas de particiones dañadas. Puede reconstruir estructuras perdidas en discos.\\
smart & Hace referencia a SMART (Self-Monitoring, Analysis and Reporting Technology), sistema que monitorea el estado físico del disco para detectar fallos. Normalmente se usa con `smartctl`.\\
efibootmgr & Administra las entradas de arranque EFI. Permite ver, crear o modificar el orden de arranque almacenado en la memoria NVRAM del sistema.\\
df -l & Muestra los sistemas de archivos montados excluyendo los remotos. Indica cuánto espacio está usado y disponible.\\
df -lh & Igual que `df`, pero en formato legible (human readable), mostrando tamaños en KB, MB o GB.\\
mount /dev/sda3 /mnt & Monta una partición en un directorio para poder acceder a su contenido. Integra el sistema de archivos al árbol principal.\\
umount /mnt & Desmonta una partición previamente montada, liberando el punto de montaje.\\
mount -o subvol=home /dev/sda3 /mnt & Monta un subvolumen específico en sistemas Btrfs. Permite separar /home de la raíz del sistema.\\
mount --bind /dev /mnt/dev & Realiza un montaje enlazado (bind mount), permitiendo que un directorio aparezca en otra ubicación. Es común antes de usar `chroot`.\\
mount --bind /sys /mnt/sys & Similar al anterior, enlaza el directorio del sistema para que esté disponible dentro de un entorno chroot.\\
less /etc/fstab & Muestra el archivo de configuración donde se definen los sistemas de archivos que se montan automáticamente al iniciar el sistema.\\
less /etc/mtab & Muestra los sistemas de archivos actualmente montados.\\
cat /etc/os-release & Muestra información sobre la distribución del sistema operativo (nombre, versión, ID).\\
chroot /mnt bash & Cambia la raíz del sistema al directorio indicado y ejecuta un shell (bash). Permite administrar o reparar un sistema desde otro entorno.\\
\end{tabular}
\end{center}
\section{Montaje de Particiones, EFI y Administración del Sistema}
\label{sec:org2247c80}

Durante esta semana se abordaron conceptos fundamentales relacionados con la
arquitectura de almacenamiento en sistemas Unix/Linux, el proceso de arranque,
el montaje de particiones y buenas prácticas administrativas.

\noindent\rule{\textwidth}{0.5pt}
\section{1. Identificación y Montaje de Particiones}
\label{sec:org1313763}

En clase analizamos cómo identificar las particiones del sistema y montarlas
manualmente utilizando el directorio /mnt como punto temporal de montaje.

El directorio /mnt está definido por el FHS (Filesystem Hierarchy Standard)
como un punto destinado a montajes temporales realizados por el administrador.

El proceso general consistió en:

\begin{itemize}
\item Identificar las particiones con herramientas como fdisk o lsblk.
\item Reconocer la partición raíz (/), la partición /boot y la partición /boot/efi.
\item Montar manualmente las particiones para inspeccionar su contenido.
\item Analizar la estructura interna del sistema de archivos.
\end{itemize}

\noindent\rule{\textwidth}{0.5pt}
\section{2. EFI (EFI System Partition)}
\label{sec:orgddf2b20}

La EFI System Partition (ESP) es una partición especial utilizada en sistemas
modernos que emplean UEFI (Unified Extensible Firmware Interface) en lugar del
BIOS tradicional.
\subsection{Características principales:}
\label{sec:orgb7f57e7}
\begin{itemize}
\item Formateada generalmente en FAT32.
\item Contiene los cargadores de arranque (.efi).
\item Se monta comúnmente en /boot/efi.
\item Es requerida en sistemas con tabla de particiones GPT.
\end{itemize}
\subsection{Proceso de arranque en sistemas UEFI:}
\label{sec:org80e6890}
\begin{enumerate}
\item Encendido del equipo.
\item Ejecución del firmware (UEFI).
\item Localización de la partición EFI.
\item Carga del bootloader (ej. GRUB).
\item Selección y carga del kernel.
\item Inicio del sistema operativo.
\end{enumerate}

La EFI permite mayor flexibilidad, soporte para discos mayores a 2TB y
mecanismos como Secure Boot.

\noindent\rule{\textwidth}{0.5pt}
\section{3. Dispositivos tipo /dev/sdX y contexto de ``sd3''}
\label{sec:orgba7cbb0}

En Linux, los dispositivos de almacenamiento se representan como block devices
dentro del directorio /dev.

Ejemplos:
\begin{itemize}
\item /dev/sda  → Primer disco detectado
\item /dev/sdb  → Segundo disco
\item /dev/sda1 → Primera partición del disco sda
\item /dev/sda3 → Tercera partición del disco sda
\end{itemize}

Cuando se mencionó “sd3”, se hacía referencia probablemente a /dev/sda3, que
corresponde a una partición específica del disco principal. Esta partición
puede contener:

\begin{itemize}
\item La raíz del sistema (/)
\item Un subvolumen en Btrfs
\item El directorio /home
\item Otro sistema de archivos independiente
\end{itemize}

En sistemas modernos es común que la raíz esté en /dev/sda3 utilizando Btrfs.

\noindent\rule{\textwidth}{0.5pt}
\section{4. Buenas prácticas: uso de usuario con privilegios sudo}
\label{sec:org911fc0e}

Una recomendación importante fue evitar trabajar directamente como root.
\subsection{Justificación técnica:}
\label{sec:orge54caf1}

En sistemas Unix existe separación de privilegios:

\begin{itemize}
\item Usuario normal → permisos limitados.
\item Root (UID 0) → control total del sistema.
\end{itemize}

Trabajar siempre como root implica riesgos:
\begin{itemize}
\item Eliminación accidental de archivos críticos.
\item Modificación indebida de configuraciones.
\item Mayor impacto ante errores humanos.
\end{itemize}
\subsection{Buena práctica recomendada:}
\label{sec:orgd614c24}
\begin{itemize}
\item Crear un usuario administrador.
\item Asignarlo al grupo sudo o wheel.
\item Elevar privilegios únicamente cuando sea necesario usando sudo.
\end{itemize}

Esto sigue el principio de:
\begin{quote}
Principio de mínimo privilegio (Principle of Least Privilege)
\end{quote}

Este principio es ampliamente recomendado en comunidades técnicas,
documentación oficial y foros especializados en administración Linux.

\noindent\rule{\textwidth}{0.5pt}
\section{5. Sistema de archivos Btrfs}
\label{sec:org9916143}

Se revisó el uso del sistema de archivos Btrfs, el cual es moderno y avanzado,
diseñado para ofrecer:

\begin{itemize}
\item Copy-on-Write (CoW)
\item Snapshots
\item Subvolúmenes
\item Compresión
\item Integridad de datos
\end{itemize}

\noindent\rule{\textwidth}{0.5pt}
\section{5.1 Opción compress=zstd:1 0 0}
\label{sec:org00c9a96}

La opción:

compress=zstd:1

es una opción de montaje en Btrfs que habilita compresión usando Zstandard.
\subsection{Componentes:}
\label{sec:org2379979}
\begin{itemize}
\item compress → activa compresión.
\item zstd → algoritmo Zstandard.
\item :1 → nivel de compresión (1 = bajo, más rápido).
\end{itemize}

Ventajas:
\begin{itemize}
\item Reduce uso de espacio en disco.
\item Mejora rendimiento en ciertos escenarios (menos I/O).
\item Transparente para el usuario.
\end{itemize}

En /etc/fstab suele verse algo como:

UUID=xxxxx  /  btrfs  defaults,compress=zstd:1  0  0

Los últimos dos valores (0 0) indican:
\begin{itemize}
\item Dump (respaldo) → generalmente 0.
\item Orden de chequeo con fsck → generalmente 0 en Btrfs.
\end{itemize}

\noindent\rule{\textwidth}{0.5pt}
\section{5.2 Subvolúmenes (subvol)}
\label{sec:org041d422}

Un subvolumen en Btrfs es una división lógica dentro del mismo sistema de
archivos.

No es una partición física, sino una estructura interna.

Ejemplo común:

\begin{itemize}
\item Subvolumen @        → raíz del sistema
\item Subvolumen @home    → directorio /home
\end{itemize}

Ventajas:
\begin{itemize}
\item Permite snapshots independientes.
\item Separación lógica sin particionar físicamente.
\item Facilita recuperación y administración.
\end{itemize}

Montaje ejemplo:

mount -o subvol=@home /dev/sda3 /mnt

\noindent\rule{\textwidth}{0.5pt}
\section{6. Archivo /etc/fstab}
\label{sec:org779c48e}

El archivo /etc/fstab define qué sistemas de archivos se montan al inicio.

Incluye:
\begin{itemize}
\item UUID
\item Punto de montaje
\item Tipo de sistema de archivos
\item Opciones de montaje
\item Flags de dump y fsck
\end{itemize}

Es clave en administración Unix para garantizar persistencia de configuración.

\noindent\rule{\textwidth}{0.5pt}
\section{7. Conceptos Complementarios Propuestos}
\label{sec:orgc560679}

A continuación se listan temas estructurales para desarrollo posterior
dentro de la materia Administración de Unix.


Esta semana permitió comprender cómo Unix/Linux organiza el almacenamiento
desde el nivel físico hasta el nivel lógico, cómo se monta el sistema de
archivos y cómo el proceso de arranque interactúa con la EFI y el bootloader.

Asimismo, se reforzaron buenas prácticas administrativas como el uso de
usuarios con privilegios controlados y la comprensión del sistema de archivos
Btrfs y sus capacidades avanzadas.

Estos conocimientos constituyen una base esencial para la administración
segura y eficiente de sistemas Unix.
\end{document}
