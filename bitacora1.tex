% Created 2026-02-09 Mon 01:29
% Intended LaTeX compiler: pdflatex
\documentclass[11pt, letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[margin=2.5cm]{geometry}      % Márgenes decentes
\usepackage[utf8]{inputenc}
\usepackage{palatino}                   % Tipografía elegante
\usepackage{xcolor}                     % Colores personalizados
\author{Equipo Alpine White}
\date{\textit{{[}2026-02-09 Mon]}}
\title{Bitácora Semanal: Administración de Sistemas Unix}
\hypersetup{
 pdfauthor={Equipo Alpine White},
 pdftitle={Bitácora Semanal: Administración de Sistemas Unix},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 28.2 (Org mode 9.7.27)}, 
 pdflang={English}}
\begin{document}

\maketitle
\setcounter{tocdepth}{2}
\tableofcontents

\section{Información General}
\label{sec:org0fc6357}
\begin{itemize}
\item \textbf{Semana:} Del 3 de Febrero 2026 al 6 de Febrero 2026
\item \textbf{Equipo:}
\begin{itemize}
\item Arreguín Salgado Gael Emiliano
\item Gramer Muñoz Omar Fernando
\item López Pérez Mariana
\item Nieto Gallegos Isaac Julián
\end{itemize}
\end{itemize}
\section{Sesión 1: 3 de Febrero 2026}
\label{sec:org9ce91af}

Esta sesión fue una introducción general a la clase y a conceptos iniciales de Linux.
\subsection{Conceptos nuevos}
\label{sec:org2468f96}

\begin{itemize}
\item \textbf{GRUB (bootloader):} GRUB (GNU GRand Unified Bootloader) es un \textbf{cargador de arranque}; es el programa que aparece al iniciar y se encarga de cargar el sistema operativo (o una ISO) y pasarle el control.
\begin{itemize}
\item \textbf{Ventoy y su GRUB:} Ventoy no usa exactamente el mismo GRUB que el del sistema instalado; incluye y arranca con su propia varainte de \textbf{GRUB2} para poder gestionar el menú y el arranque de múltiples ISOs desde una sola USB.
\item \textbf{Consola de GRUB en Ventoy:} En el menú de Ventoy/GRUB, al presionar la tecla \texttt{C} se abre la \textbf{consola} (tipo terminal) de GRUB.
\begin{itemize}
\item En esta consola podemos inspeccionar y explorar qué ve el bootloader (discos/particiones/archivos) y consultar variables o configuración.
\item Comandos:
\begin{verbatim}
      ls
      help
      set
      ls (hd0,gpt1)/
      cat (hd0,gpt1)/boot/grub/grub.cfg
\end{verbatim}
\item Esto sirve para tipo depurar, inspeccionar por qué algo no arranca como debe, confirmar rutas, o entender cómo Ventoy/GRUB está resolviendo la configuración.
\end{itemize}
\end{itemize}

\item El comando ls nos permite listar los contenidos del directorio en el que nos encontramos actualmente. Usando los parámetros -la, podemos colocarlos en forma de lista y mostrar archivos ocultos para tener una vista más general y completa del directorio. Por ejemplo:
\end{itemize}

\begin{verbatim}
ls -la
\end{verbatim}

\phantomsection
\label{}
\begin{verbatim}
total 416
drwxr-xr-x 3 gael gael   4096 Feb  9 00:56 .
drwxr-xr-x 3 gael gael   4096 Feb  9 00:56 ..
-rw-r--r-- 1 gael gael  18943 Feb  9 01:27 bitacora1.org
-rw-r--r-- 1 gael gael 230261 Feb  9 00:56 bitacora1.pdf
-rw-r--r-- 1 gael gael  19529 Feb  9 00:56 bitacora1.tex
drwxr-xr-x 8 gael gael   4096 Feb  9 01:29 .git
-rw-r--r-- 1 gael gael     25 Feb  9 00:56 test.txt
-rw-r--r-- 1 gael gael 133687 Feb  9 00:56 ventoy_boot.jpg
\end{verbatim}


\begin{itemize}
\item Ventoy es una herramienta que nos permite poder arrancar varias imágenes ISO desde una misma memoria USB. Se instala sobre la memoria USB, y recursivamente busca las imágenes ISO que contenga para mostrarlas en el menú de arranque. Se nos queda de tarea para la próxima semana traer una memoria USB con Ventoy instalado.

\begin{center}
\includegraphics[width=.9\linewidth]{./ventoy_boot.jpg}
\end{center}

\item Existen dos formas de referenciar un archivo en Linux: Mediante su ruta relativa y mediante su ruta absoluta. Generalmente una ruta relativa empieza por un ./ o ../, mientras que una ruta absoluta empieza por /, ya que es la ruta completa al archivo desde la raíz del sistema de archivos. Por ejemplo:
\end{itemize}

\begin{verbatim}
echo este es el mismo archivo > test.txt
cat /home/mrtaichi/Documents/escuela/adminUnix/test.txt # Ruta absoluta
cat ./test.txt # Ruta relativa
\end{verbatim}

\phantomsection
\label{}
\begin{verbatim}
este es el mismo archivo
\end{verbatim}


\begin{itemize}
\item LAN? (en proceso)

\item En Linux, \ref{sec:orgff89e4c}. Esto incluye a los dispositivos, ya que la carpeta /dev guarda representaciones en archivo de todos los dispositivos que están conectados a la computadora. Esto incluye desde los mismos dispositivos de almacenamiento, hasta cosas más ``virtuales'' como las terminales y pseudoterminales del sistema.

\item Dispositivo psar? (en proceso)

\item Gparted es una herramienta con interfaz gráfica para crear y modificar particiones en un disco.
\end{itemize}
\subsection{Conceptos de repaso}
\label{sec:org30f63f8}

\begin{itemize}
\item \textbf{Proceso de arranque (boot process):}
Secuencia general: BIOS/UEFI → bootloader (GRUB) → kernel → init/systemd.
Punto clave: el sistema operativo \textbf{no existe} mientras estamos en GRUB; solo existe firmware con bootloader.

\item \textbf{Bootloader vs Kernel:}
GRUB no es el sistema operativo ni el kernel.
Su única responsabilidad es localizar, cargar el kernel (y el initramfs) en memoria y cederle el control.
No ejecuta procesos ni gestiona recursos del sistema.

\item \textbf{Separación de responsabilidades:}
Ventoy delega completamente el arranque a GRUB y evita modificar el disco.
Ejemplo de buen diseño: cada componente hace una sola cosa bien definida.

\item \textbf{Acceso a disco antes del kernel:}
GRUB puede leer sistemas de archivos (FAT, EXT, ISO) sin drivers del kernel.

\item \textbf{Lectura de archivos sin montaje:}
El bootloader accede directamente a estructuras del sistema de archivos.
Montar un FS es una abstracción que pertenece al kernel, no al bootloader.
\end{itemize}
\subsection{Máximas}
\label{sec:org0176b3c}

\subsubsection{Todo es un archivo}
\label{sec:orgff89e4c}
En los sistemas derivados de Unix, como Linux
\subsection{Sección libre}
\label{sec:org65d81c0}
\section{Sesión 2: 4 de Febrero 2026}
\label{sec:orgeef7e2a}

\subsection{Conceptos nuevos}
\label{sec:org9035210}

\begin{itemize}
\item Estuvimos hablando de la importancia de la redundancia para preservar la información. Como ejemplo usamos el sistema RAID, que utiliza varios discos duros para crear replicación de información y tolerancia a fallos.

\item La necesidad principal de tener redundancia en la información es para no tener un sólo punto de falla en nuestros sistemas que pueda fallar. Si alguna parte de nuestro sistema falla, siempre existe otro componente listo para tomar el lugar y mantener el sistema funcionando.

\item Generalmente la emulación es más lenta que la virtualización. El primer sistema de WSL usaba emulación de Linux, ahora el segundo utiliza virtualización.

\item El propósito de que cada quien utilice una distribución distinta es demostrar la máxima: ``\ref{sec:org81d1a40}''. Vamos a observar como -en esencia- todos las distribuciones de Linux tienen tantas cosas en común que podemos hacer cualquier cosa en cualquier distro.

\item Distrowatch es un sitio web en el que se pueden observar todas las distribuciones de Linux y muchos datos acerca de ellas. Lo que resulta interesante es que incluso un ranking de cuáles son las distros más usadas hasta el mometo.

\item SCSI (que se pronuncia ``scuzzy'') es una interfaz de intercambio de datos que se utiliza sobre todo en servidores y computadoras de alto desempeño. Hablando del sistema RAID, es generalmente sobre esta interfaz sobre la que se construyen varios controladores RAID que están en la industria.
\end{itemize}
\subsection{Conceptos de repaso}
\label{sec:org454902f}

\subsection{Máximas}
\label{sec:orgd9e4d32}
\subsubsection{Todos los Linux son iguales}
\label{sec:org81d1a40}
En cualquier distribución de Linux podemos -a final de cuentas- hacer cualquier cosa. Todas funcionan esencialmente para lo mismo, y aunque evidentemente hay diferencias, se puede trabajar con ellas sin problema.
\subsection{Sección libre}
\label{sec:org64fc9c9}
\section{Sesión 3: 5 de Febrero 2026}
\label{sec:org00669ac}

\subsection{Conceptos nuevos}
\label{sec:orge6ffd06}

\begin{itemize}
\item Unix nace en 1969 como un sistema operativo desarrollado en Bell Labs, al principio con fines académicos y distribuido para varias universidades. De ahí nace BSD cuando se vuelve comercial

\item Y de ahí también nace Linux, como un kernel Unix-like desarrollado en 1991 por Linus Torvalds, el cual se termina fusionando con GNU para formar un sistema operativo completo.

\item Un proceso es un programa que se está ejecutando en el sistema y constantemente le está pidiendo recursos al kernel. Los procesos se comunican con el kernel a través de syscalls
\end{itemize}
\subsection{Conceptos de repaso}
\label{sec:org3db27a5}

\subsection{Máximas}
\label{sec:org7d9367b}

\subsection{Sección libre}
\label{sec:orged19921}

Para entender mejor el funcionamiento de un proceso, se me ocurrió meterme al código fuente de Linux y, con ayuda de la IA, aprender acerca de la estructura que conforma un proceso como tal.

Primero había que ubicarla, y después de indagar un rato en la documentación me pude dar cuenta de que el término usado en el kernel para referirse a los procesos es una task (o tarea). Esto debido a que esta estructura sirve tanto para procesos de programas como para los hilos de un mismo programa. La estructura que buscamos es entonces task\textsubscript{struc}, la cual se encuentra declarada en include/linux/sched.h

Como el código que define esta estructura es muy extenso, es aquí donde me tuve que servir de la IA para entenderle. Le pasé el archivo y le pedí una explicación sobre cada uno de los componentes de esta estructura. Este fue el resultado:

\begin{quote}
Entiendo perfectamente, la `struct task\textsubscript{struct}` es intimidante porque es el ``corazón'' de Linux y contiene prácticamente todo lo que el kernel sabe sobre un proceso. Basado en el archivo `sched.h` que compartiste, vamos a despedazarla en partes lógicas para que sea más fácil de digerir.

Piensa en la `task\textsubscript{struct}` como el \textbf{\textbf{expediente completo}} de una persona en una oficina gubernamental; tiene su nombre, su familia, su dinero, sus propiedades y qué está haciendo en este momento.

\#\#\# 1. Estado y Propósito (¿Qué está haciendo?)

Lo primero que el kernel necesita saber es si el proceso puede correr o si está esperando algo.

\textbf{\textbf{*`\_\textsubscript{state}`}}: Define si el proceso está `TASK\textsubscript{RUNNING}` (listo para usar la CPU), `TASK\textsubscript{INTERRUPTIBLE}` (durmiendo pero puede despertar con una señal) o en otros estados como `TASK\textsubscript{DEAD}`.
\textbf{\textbf{*`stack`}}: Un puntero al stack del kernel para este proceso específico.
\textbf{\textbf{*`flags`}}: Banderas que indican atributos especiales (por ejemplo, si es un hilo del kernel o si está saliendo).

\#\#\# 2. Identificación (¿Quién es?)

\textbf{\textbf{*`pid`}}: El \textbf{Process ID} único que ves cuando usas comandos como `top`.
\textbf{\textbf{*`tgid`}}: El \textbf{Thread Group ID}. En Linux, para el hilo principal, el PID y el TGID son iguales. Si creas más hilos en ese proceso, todos compartirán el mismo TGID pero tendrán PIDs distintos.
\textbf{\textbf{*`comm[TASK\textsubscript{COMM}\textsubscript{LEN}]`}}: El nombre del ejecutable (máximo 16 caracteres).

\#\#\# 3. El Planificador (¿Cuándo le toca la CPU?)

Esta sección decide la prioridad del proceso.

***`prio`, `static\textsubscript{prio}`, `normal\textsubscript{prio}**`: Las distintas prioridades que el planificador usa para decidir a quién darle la CPU.
***`se`, `rt`, `dl**`: Estas son sub-estructuras (`sched\textsubscript{entity}`, `sched\textsubscript{rt}\textsubscript{entity}`, etc.) que contienen los datos específicos para diferentes tipos de procesos (normales, de tiempo real, etc.).

\#\#\# 4. Relaciones Familiares (¿Quién lo creó?)

Linux organiza los procesos en un árbol genealógico.

\textbf{\textbf{*`parent`}}: Puntero al proceso padre.
\textbf{\textbf{*`children`}}: Una lista de todos los procesos hijos que este proceso ha creado.
\textbf{\textbf{*`sibling`}}: Enlaces a sus ``hermanos'' (otros procesos creados por el mismo padre).

\#\#\# 5. Recursos (¿Qué posee?)

Aquí es donde la estructura se conecta con el resto del sistema.

\textbf{\textbf{*`mm`}}: Puntero a `struct mm\textsubscript{struct}`. Aquí reside toda la información de la \textbf{\textbf{memoria virtual}} del proceso (sus páginas, segmentos, etc.).
\textbf{\textbf{*`files`}}: Puntero a `struct files\textsubscript{struct}`. Es la tabla que guarda todos los \textbf{\textbf{archivos abiertos}} (tus descriptores de archivo 0, 1, 2, etc.).
\textbf{\textbf{*`fs`}}: Información del sistema de archivos, como el directorio actual (`pwd`).
\textbf{\textbf{*`cred`}}: Las credenciales de seguridad (quién es el dueño: UID, GID).

\#\#\# 6. Señales (¿Qué le han dicho?)

\textbf{\textbf{*`signal`}} y \textbf{\textbf{`sighand`}}: Manejan qué debe hacer el proceso cuando recibe señales como un `SIGKILL` o `SIGTERM`.
\textbf{\textbf{*`pending`}}: Una lista de señales que han llegado pero que el proceso aún no ha procesado.

\textbf{\textbf{Resumen rápido para no volverse loco:}}
Si estás programando en el kernel y tienes un puntero a un proceso (usualmente llamado `p` o `current`), lo más común es que solo te interesen `p->pid`, `p->comm`, `p->mm` (memoria) o `p->files` (archivos). El resto son detalles técnicos para que el kernel gestione la magia por debajo.

¿Hay alguna de estas secciones que te interese explorar más a fondo con el código que pasaste?
\end{quote}

De esto ya pude entender mejor cómo funciona el tema de los procesos en Linux y la relación de parentesco que debe existir entre todos ellos que los lleva al proceso inicial (systemd).
\section{Sesión 4: 6 de Febrero 2026}
\label{sec:orgc766e89}

\subsection{Conceptos nuevos}
\label{sec:org585a4ab}

\begin{itemize}
\item Linux tiene un directorio llamado /tmp el cual es volátil. Ahí se guardan todos los archivos que se necesitan para el funcionamiento de los programas y SO durante la sesión, pero que no son necesarios de conservarse y por lo tanto se pueden borrar en el siguiente apagado. En Windows existe la misma implementación en una carpeta llamada Temp

\item nohup es un comando que nos permite ejecutar procesos y evitar que mueran cuando el padre muera.

\begin{verbatim}
man nohup
\end{verbatim}

\phantomsection
\label{}
\begin{verbatim}
  NOHUP(1)                         User Commands                        NOHUP(1)

  NAME
         nohup - run a command immune to hangups, with output to a non-tty

  SYNOPSIS
         nohup COMMAND [ARG]...
         nohup OPTION

  DESCRIPTION
         Run COMMAND, ignoring hangup signals.

         --help display this help and exit

         --version
                output version information and exit

         If  standard  input is a terminal, redirect it from an unreadable file.
         If standard output is a terminal, append output to 'nohup.out' if  pos‐
         sible,  '$HOME/nohup.out'  otherwise.  If standard error is a terminal,
         redirect it to standard output.  To save output  to  FILE,  use  'nohup
         COMMAND > FILE'.

         NOTE:  your  shell may have its own version of nohup, which usually su‐
         persedes the version described here.  Please refer to your shell's doc‐
         umentation for details about the options it supports.

  AUTHOR
         Written by Jim Meyering.

  REPORTING BUGS
         GNU coreutils online help: <https://www.gnu.org/software/coreutils/>
         Report any translation bugs to <https://translationproject.org/team/>

  COPYRIGHT
         Copyright  ©  2022  Free Software Foundation, Inc.  License GPLv3+: GNU
         GPL version 3 or later <https://gnu.org/licenses/gpl.html>.
         This is free software: you are free  to  change  and  redistribute  it.
         There is NO WARRANTY, to the extent permitted by law.

  SEE ALSO
         Full documentation <https://www.gnu.org/software/coreutils/nohup>
         or available locally via: info '(coreutils) nohup invocation'

  GNU coreutils 9.1               September 2022                        NOHUP(1)
\end{verbatim}

\item Con el comando pstree podemos ver un árbol de los procesos en ejecución actualmente en nuestro sistema. Esto nos da una vista muy clara de las relaciones de parentesco de todos estos.
\end{itemize}

\begin{verbatim}
pstree
\end{verbatim}

\phantomsection
\label{}
\begin{verbatim}
systemd-+-ModemManager---2*[{ModemManager}]
        |-NetworkManager---2*[{NetworkManager}]
        |-accounts-daemon---2*[{accounts-daemon}]
        |-avahi-daemon---avahi-daemon
        |-bluetoothd
        |-colord---2*[{colord}]
        |-containerd---12*[{containerd}]
        |-cron
        |-cups-browsed---2*[{cups-browsed}]
        |-cupsd
        |-dbus-daemon
        |-dockerd---13*[{dockerd}]
        |-exim4
        |-fwupd---4*[{fwupd}]
        |-gdm3-+-gdm-session-wor-+-gdm-wayland-ses-+-gnome-session-b---3*[{gnome-session-b}]
        |      |                 |                 `-2*[{gdm-wayland-ses}]
        |      |                 `-2*[{gdm-session-wor}]
        |      `-2*[{gdm3}]
        |-geoclue---3*[{geoclue}]
        |-low-memory-moni---2*[{low-memory-moni}]
        |-polkitd---2*[{polkitd}]
        |-power-profiles----2*[{power-profiles-}]
        |-rtkit-daemon---2*[{rtkit-daemon}]
        |-switcheroo-cont---2*[{switcheroo-cont}]
        |-systemd-+-(sd-pam)
        |         |-at-spi2-registr---2*[{at-spi2-registr}]
        |         |-crashhelper---{crashhelper}
        |         |-dbus-daemon
        |         |-dconf-service---2*[{dconf-service}]
        |         |-emacs
        |         |-evolution-addre---5*[{evolution-addre}]
        |         |-evolution-calen---8*[{evolution-calen}]
        |         |-evolution-sourc---3*[{evolution-sourc}]
        |         |-gcr-ssh-agent---{gcr-ssh-agent}
        |         |-2*[gjs---10*[{gjs}]]
        |         |-gnome-calendar---5*[{gnome-calendar}]
        |         |-gnome-keyring-d---3*[{gnome-keyring-d}]
        |         |-gnome-session-b-+-at-spi-bus-laun-+-dbus-daemon
        |         |                 |                 `-3*[{at-spi-bus-laun}]
        |         |                 |-evolution-alarm---5*[{evolution-alarm}]
        |         |                 |-gnome-software---7*[{gnome-software}]
        |         |                 |-gsd-disk-utilit---2*[{gsd-disk-utilit}]
        |         |                 `-3*[{gnome-session-b}]
        |         |-gnome-session-c---{gnome-session-c}
        |         |-gnome-shell-+-Xwayland---6*[{Xwayland}]
        |         |             |-firefox-esr-+-Isolated Servic---27*[{Isolated Servic}]
        |         |             |             |-Isolated Web Co---29*[{Isolated Web Co}]
        |         |             |             |-Isolated Web Co---32*[{Isolated Web Co}]
        |         |             |             |-4*[Isolated Web Co---27*[{Isolated Web Co}]]
        |         |             |             |-Isolated Web Co---28*[{Isolated Web Co}]
        |         |             |             |-Privileged Cont---28*[{Privileged Cont}]
        |         |             |             |-RDD Process---4*[{RDD Process}]
        |         |             |             |-Socket Process---6*[{Socket Process}]
        |         |             |             |-Utility Process---4*[{Utility Process}]
        |         |             |             |-3*[Web Content---17*[{Web Content}]]
        |         |             |             |-WebExtensions---26*[{WebExtensions}]
        |         |             |             `-125*[{firefox-esr}]
        |         |             `-20*[{gnome-shell}]
        |         |-gnome-shell-cal---5*[{gnome-shell-cal}]
        |         |-gnome-terminal--+-zsh---emacs-+-bash---pstree
        |         |                 |             |-emacs
        |         |                 |             `-3*[{emacs}]
        |         |                 `-3*[{gnome-terminal-}]
        |         |-goa-daemon---3*[{goa-daemon}]
        |         |-goa-identity-se---2*[{goa-identity-se}]
        |         |-gsd-a11y-settin---3*[{gsd-a11y-settin}]
        |         |-gsd-color---3*[{gsd-color}]
        |         |-gsd-datetime---3*[{gsd-datetime}]
        |         |-gsd-housekeepin---3*[{gsd-housekeepin}]
        |         |-gsd-keyboard---3*[{gsd-keyboard}]
        |         |-gsd-media-keys---3*[{gsd-media-keys}]
        |         |-gsd-power---4*[{gsd-power}]
        |         |-gsd-print-notif---2*[{gsd-print-notif}]
        |         |-gsd-printer---2*[{gsd-printer}]
        |         |-gsd-rfkill---2*[{gsd-rfkill}]
        |         |-gsd-screensaver---2*[{gsd-screensaver}]
        |         |-gsd-sharing---3*[{gsd-sharing}]
        |         |-gsd-smartcard---4*[{gsd-smartcard}]
        |         |-gsd-sound---3*[{gsd-sound}]
        |         |-gsd-usb-protect---3*[{gsd-usb-protect}]
        |         |-gsd-wacom---3*[{gsd-wacom}]
        |         |-gsd-xsettings---7*[{gsd-xsettings}]
        |         |-gvfs-afc-volume---3*[{gvfs-afc-volume}]
        |         |-gvfs-goa-volume---2*[{gvfs-goa-volume}]
        |         |-gvfs-gphoto2-vo---2*[{gvfs-gphoto2-vo}]
        |         |-gvfs-mtp-volume---2*[{gvfs-mtp-volume}]
        |         |-gvfs-udisks2-vo---3*[{gvfs-udisks2-vo}]
        |         |-gvfsd-+-gvfsd-dnssd---2*[{gvfsd-dnssd}]
        |         |       |-gvfsd-network---3*[{gvfsd-network}]
        |         |       |-gvfsd-recent---2*[{gvfsd-recent}]
        |         |       |-gvfsd-trash---2*[{gvfsd-trash}]
        |         |       `-2*[{gvfsd}]
        |         |-gvfsd-fuse---5*[{gvfsd-fuse}]
        |         |-gvfsd-metadata---2*[{gvfsd-metadata}]
        |         |-ibus-portal---2*[{ibus-portal}]
        |         |-ibus-x11---2*[{ibus-x11}]
        |         |-pipewire---{pipewire}
        |         |-pipewire-pulse---{pipewire-pulse}
        |         |-sd_dummy---2*[{sd_dummy}]
        |         |-sd_espeak-ng---{sd_espeak-ng}
        |         |-sh---ibus-daemon-+-ibus-engine-sim---2*[{ibus-engine-sim}]
        |         |                  |-ibus-extension----3*[{ibus-extension-}]
        |         |                  |-ibus-memconf---2*[{ibus-memconf}]
        |         |                  `-2*[{ibus-daemon}]
        |         |-speech-dispatch---4*[{speech-dispatch}]
        |         |-ssh-agent
        |         |-tracker-miner-f---5*[{tracker-miner-f}]
        |         |-wireplumber---3*[{wireplumber}]
        |         |-xdg-desktop-por---5*[{xdg-desktop-por}]
        |         |-2*[xdg-desktop-por---3*[{xdg-desktop-por}]]
        |         |-xdg-document-po-+-fusermount3
        |         |                 `-5*[{xdg-document-po}]
        |         `-xdg-permission----2*[{xdg-permission-}]
        |-systemd-journal
        |-systemd-logind
        |-systemd-timesyn---{systemd-timesyn}
        |-systemd-udevd
        |-udisksd---4*[{udisksd}]
        |-upowerd---2*[{upowerd}]
        `-wpa_supplicant
\end{verbatim}

\begin{itemize}
\item De aquí podemos observar una vez más como el proceso más importante y del que nacen todos los procesos en espacio de usuario es el proceso systemd. Además, observamos algunas cosillas interesantes como los procesos que generan nuestro entorno de escritorio, pipewire para el sonido, etc.
\end{itemize}
\subsection{Conceptos de repaso}
\label{sec:org8330e44}

\begin{itemize}
\item Me parece que nohup ya había sido visto?
\end{itemize}
\subsection{Máximas}
\label{sec:orgd7fc115}

\subsection{Sección libre}
\label{sec:org79f8345}
\end{document}
