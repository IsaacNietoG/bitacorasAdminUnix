#+TITLE: Bitácora Semanal: Administración de Sistemas Unix
#+AUTHOR: Equipo Alpine White
#+DATE: [2026-02-09 lun]
#+OPTIONS: toc:2
#+PROPERTY: header-args :exports both
#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS: [11pt, letterpaper]
#+LATEX_HEADER: \usepackage[margin=2.5cm]{geometry}      % Márgenes decentes
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+LATEX_HEADER: \usepackage{palatino}                   % Tipografía elegante
#+LATEX_HEADER: \usepackage{xcolor}                     % Colores personalizados

* Información General
- *Semana:* Del 3 de Febrero 2026 al 6 de Febrero 2026
- *Equipo:*
  - Arreguín Salgado Gael Emiliano
  - Gramer Muñoz Omar Fernando
  - López Pérez Mariana
  - Nieto Gallegos Isaac Julián

En esta nuestra primera semana de clases, el enfoque fue particularmente en entender el arranque del sistema operativo, el sistema de archivos y comenzar a prepararnos para elegir la distribución con la que iremos trabajando en el semestre.

* GRUB Y SISTEMAS DE ARRANQUE

** Conceptos nuevos

*** Proceso de arranque
- Ejecucion de firmware
- Localizacion de la EFI System Partition
- Carga del bootloader
- Selección y carga de kernel
- Inicio del sistema operativo

*** Firmware definicion
- BIOS y UEFI ( y sus diferencias )

*** Bootloader / Gestores de arranque definicion

**** GRUB
GRUB (GNU GRand Unified Bootloader) es un *cargador de arranque*; es el programa que aparece al iniciar y se encarga de cargar el sistema operativo (o una ISO) y pasarle el control.

**** Windows boot manager

**** Secure boot

MOK database

**** Ventoy

Ventoy es una herramienta que nos permite poder arrancar varias imágenes ISO desde una misma memoria USB. Se instala sobre la memoria USB, y recursivamente busca las imágenes ISO que contenga para mostrarlas en el menú de arranque. Se nos queda de tarea para la próxima semana traer una memoria USB con Ventoy instalado.

  [[./ventoy_boot.jpg]]


- *Ventoy y su GRUB:* Ventoy no usa exactamente el mismo GRUB que el del sistema instalado; incluye y arranca con su propia varainte de *GRUB2* para poder gestionar el menú y el arranque de múltiples ISOs desde una sola USB.

- *Consola de GRUB en Ventoy:* En el menú de Ventoy/GRUB, al presionar la tecla ~C~ se abre la *consola* (tipo terminal) de GRUB.
  - En esta consola podemos inspeccionar y explorar qué ve el bootloader (discos/particiones/archivos) y consultar variables o configuración.
  - Comandos:
        #+begin_src
        ls
        help
        set
        ls (hd0,gpt1)/
        cat (hd0,gpt1)/boot/grub/grub.cfg
        #+end_src
  - Esto sirve para tipo depurar, inspeccionar por qué algo no arranca como debe, confirmar rutas, o entender cómo Ventoy/GRUB está resolviendo la configuración.



** Conceptos de repaso
- *Proceso de arranque (boot process):*
  Secuencia general: BIOS/UEFI → bootloader (GRUB) → kernel → init/systemd.
  Punto clave: el sistema operativo *no existe* mientras estamos en GRUB; solo existe firmware con bootloader.

- *Bootloader vs Kernel:*
  GRUB no es el sistema operativo ni el kernel.
  Su única responsabilidad es localizar, cargar el kernel (y el initramfs) en memoria y cederle el control.
  No ejecuta procesos ni gestiona recursos del sistema.

- *Separación de responsabilidades:*
  Ventoy delega completamente el arranque a GRUB y evita modificar el disco.
  Ejemplo de buen diseño: cada componente hace una sola cosa bien definida.

- *Acceso a disco antes del kernel:*
  GRUB puede leer sistemas de archivos (FAT, EXT, ISO) sin drivers del kernel.

- *Lectura de archivos sin montaje:*
  El bootloader accede directamente a estructuras del sistema de archivos.
  Montar un FS es una abstracción que pertenece al kernel, no al bootloader.

** Máximas

*** Todo es un archivo
En los sistemas derivados de Unix, como Linux


** Sección libre

- El comando ls nos permite listar los contenidos del directorio en el que nos encontramos actualmente. Usando los parámetros -la, podemos colocarlos en forma de lista y mostrar archivos ocultos para tener una vista más general y completa del directorio. Por ejemplo:

#+begin_src bash :results verbatim
ls -la
#+end_src

#+RESULTS:
: total 8
: drwxr-xr-x 1 mrtaichi mrtaichi   48 Feb  7 11:58 .
: drwxr-xr-x 1 mrtaichi mrtaichi   32 Feb  4 09:26 ..
: -rw-r--r-- 1 mrtaichi mrtaichi 2014 Feb  6 09:40 apuntes.org
: -rw-r--r-- 1 mrtaichi mrtaichi  407 Feb  7 12:08 bitacora1.org

- Existen dos formas de referenciar un archivo en Linux: Mediante su ruta relativa y mediante su ruta absoluta. Generalmente una ruta relativa empieza por un ./ o ../, mientras que una ruta absoluta empieza por /, ya que es la ruta completa al archivo desde la raíz del sistema de archivos. Por ejemplo:

#+begin_src bash :results verbatim
echo este es el mismo archivo > test.txt
cat /home/mrtaichi/Documents/escuela/adminUnix/test.txt # Ruta absoluta
cat ./test.txt # Ruta relativa
#+end_src

#+RESULTS:
: este es el mismo archivo
: este es el mismo archivo

---------------------------------------------------------------------------
* Disponibilidad del sistema: RAID y puntos únicos de falla

** Conceptos nuevos
*** Alta disponibilidad
*** Redundancia
*** Tolerancia a fallos
*** Punto único de falla (Single Point of Failure)

*** Técnicas de Protección de datos
**** Replicación
**** Paridad
**** Backups vs redundancia

*** RAID (Redundant Array of Independent Disks)
**** Concepto general
**** Objetivos: rendimiento vs seguridad
**** RAID por hardware vs RAID por software
**** Niveles de RAID
***** RAID 0
***** RAID 1
***** RAID 5
***** RAID 6
***** RAID 10


** Conceptos de repaso

** Maximas

** Seccion libre

---------------------------------------------------------------------------
* De Unix a GNU/Linux: Origen, Filosofía y Evolución del Software Libre
    -  Origen y evolución de Unix
      - Contexto académico
      - Nacimiento de Unix (1969)
        - Desarrollo en Bell Labs
        - Linus Torvalds
        - Sistema Unix-like
          - Diferencia entre Unix y Unix-like
      - Filosofía Unix (simplicidad, modularidad, herramientas pequeñas que hacen una sola cosa)

    - Proyecto GNU
      - Filosofía del software libre
      - Herramientas GNU (gcc, bash, coreutils)
      - Licencia GPL

    - GNU/Linux como sistema completo
      - Integración del kernel Linux con herramientas GNU
      - Concepto de distribución (Ubuntu, Debian, etc.)

    - Comercialización de Unix
      - Versiones propietarias
      - Impacto en la industria


---------------------------------------------------------------------------
* Kernel
    - Definición de kernel
      - Intermediario entre hardware y software

    - Rol del kernel
      - Gestión de CPU, memoria y dispositivos
      - Planificación (scheduling)
      - Gestión de memoria
      - Control de dispositivos
      - Manejo de interrupciones

    - Llamadas al sistema (System Calls)
      - Interfaz entre espacio de usuario y kernel
      - Ejemplos: fork(), exec(), read(), write()
      - Cambio de modo usuario a modo kernel

    - Espacio de usuario vs espacio de kernel
      - Separación de privilegios
      - Seguridad y protección del sistema

---------------------------------------------------------------------------
* Modelo de Ejecución y Gestión de Procesos en Linux
    - Programa vs Proceso
      - Definición de programa
      - Definición de proceso
      - Ciclo de vida de un proceso

    - Procesos y Tareas en Linux
      - Qué es una tarea (task)
      - Concepto de hilo (thread)
      - Diferencia entre proceso e hilo (thread)
      - Identificador de proceso (PID)
      - Estados de un proceso (running, ready, waiting, stopped, zombie)

    - Espacio de Usuario vs Espacio de Kernel
      - Separación de privilegios
      - Protección de memoria
      - Cambio de modo (user mode ↔ kernel mode)

    - System Calls (Llamadas al Sistema)
      - Mecanismo para que un proceso solicite servicios al kernel
      - Interfaz entre usuario y kernel
      - Cambio de contexto
      - Ejemplos comunes de syscalls: fork(), exec(), wait(), read(), write(), open(), exit()

    - Flujo básico de una system call
      - Interrupción o instrucción especial (syscall/sysenter)
      - El proceso solicita un servicio
      - El CPU cambia a modo kernel
      - El kernel ejecuta la operación
      - Se regresa al modo usuario

    - Representación Interna de Procesos en Linux
      - struct task_struct
        - Estructura que representa un proceso en el kernel
        - Contiene:
          - PID
          - Estado
          - Prioridad
          - Información básica de memoria

    - Qué es el scheduler
      - Asignación de CPU a procesos
      - Cambio de contexto (context switch)
      - Procesos con mayor o menor prioridad
      - Tiempo de CPU compartido
      - sched.h (visión general)
        - Definición de políticas de planificación
        - Constantes relacionadas con scheduling
        - Interacción con task_struct

    - Comandos útiles
      - pstree
      - nohup


---------------------------------------------------------------------------
* Arquitectura de almacenamiento físico y su representación en Linux
    - Dispositivos de almacenamiento
      - HDD vs SSD
      - NVMe vs SATA
      - Rendimiento, latencia e IOPS
      - Persistencia vs volatilidad

    - Representación en Linux
      - Dispositivos en /dev
        - /dev/sda
        - /dev/sdb
        - /dev/nvme0n1
      - Concepto de block device
      - Uso de lsblk y blkid

    - Interfaces de comunicación de discos
      - SCSI
      - SAS (Serial Attached SCSI)
      - SATA (Serial ATA)
      - NVMe (Non-Volatile Memory Express)

    - Particiones
      - ¿Qué es una partición?
      - División lógica del disco
      - Independencia de particiones
      - Concepto de sector y bloque

    - Tablas de partición
      - MBR (Master Boot Record)
      - GPT (GUID Partition Table)
      - Diferencias técnicas (límite 2TB, número de particiones, redundancia)

    - Tipos de particiones (MBR)
      - Primaria
      - Extendida
      - Lógica

    - Herramientas de particionado
      - fdisk
      - cfdisk
      - parted
      - gparted


---------------------------------------------------------------------------
* Estructura lógica y administración de sistemas de archivos

    - ¿Qué es un sistema de archivos?
      - Organización lógica de datos
      - Relación con particiones
      - Abstracción sobre el hardware

    - Sistemas de archivos comunes en Linux
      - ext4, xfs, btrfs, vfat, ntfs

    - Estructura interna básica de un archivo
      - Superbloque
      - Inodos
      - Bloques de datos
      - Journaling
      - Metadatos

    - Creación y formateo de particiones
      - mkfs
      - mkfs.ext4
      - mkfs.xfs
      - Verificación con fsck

    - Montaje
      - mount
      - umount
      - Puntos de montaje (/mnt, /media)
      - Montaje temporal vs permanente

    - Archivo /etc/fstab
      - Montaje automático al inicio
      - UUID vs nombre de dispositivo
      - Opciones comunes (defaults, noatime, ro, rw)



---------------------------------------------------------------------------

* Permisos y Propiedad
      - Lectura (r)
      - Escritura (w)
      - Ejecución (x)
      - comandos para ver esto ( ls -la )

      - Conceptos de Usuarios y grupos
        - Propietario
        - Grupo
        - Otros
        - Comandos relacionados
          - chmod
          - chown
          - chgrp

