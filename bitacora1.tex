% Created 2026-02-18 Wed 21:54
% Intended LaTeX compiler: pdflatex
\documentclass[11pt, letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[margin=2.5cm]{geometry}      % Márgenes decentes
\usepackage[utf8]{inputenc}
\usepackage{palatino}                   % Tipografía elegante
\usepackage{xcolor}                     % Colores personalizados
\author{Equipo Alpine White}
\date{\textit{{[}2026-02-09 Mon]}}
\title{Bitácora Semanal: Administración de Sistemas Unix}
\hypersetup{
 pdfauthor={Equipo Alpine White},
 pdftitle={Bitácora Semanal: Administración de Sistemas Unix},
 pdfkeywords={},
 pdfsubject={},
 pdfcreator={Emacs 30.2 (Org mode 9.7.29)}, 
 pdflang={English}}
\begin{document}

\maketitle
\setcounter{tocdepth}{2}
\tableofcontents

\section{Información General}
\label{sec:orgec3c6aa}
\begin{itemize}
\item \textbf{Semana:} Del 3 de Febrero 2026 al 6 de Febrero 2026
\item \textbf{Equipo:}
\begin{itemize}
\item Arreguín Salgado Gael Emiliano
\item Gramer Muñoz Omar Fernando
\item López Pérez Mariana
\item Nieto Gallegos Isaac Julián
\end{itemize}
\end{itemize}

En esta nuestra primera semana de clases, el enfoque fue particularmente en entender el arranque del sistema operativo, el sistema de archivos y comenzar a prepararnos para elegir la distribución con la que iremos trabajando en el semestre.
\subsection{Responsabilidades:}
\label{sec:org19eaded}
Gael Emiliano: Secciones de GRUB, RAID y varias aportaciones de bloques de código y revisión de detalles sobre lo visto en clase.

Omar Fernando: Propuesta de estructura del archivo y arreglo de temas de la semana

Mariana: Captura de temas de la semana, aportaciones de detalles sobre los temas vistos en clase.

Isaac Julián: Conciliación con estructura previa del trabajo. Bloques de código y ``compilado'' de archivo org a pdf.
\section{GRUB Y SISTEMAS DE ARRANQUE}
\label{sec:org7b48497}

\subsection{Conceptos nuevos}
\label{sec:org21c9475}

\subsubsection{Proceso de arranque}
\label{sec:orgf790092}
\begin{itemize}
\item Ejecucion de firmware
\item Localizacion de la EFI System Partition
\item Carga del bootloader
\item Selección y carga de kernel
\item Inicio del sistema operativo
\end{itemize}
\subsubsection{Firmware definicion}
\label{sec:org71b728f}
\begin{itemize}
\item BIOS y UEFI ( y sus diferencias )
\end{itemize}
\subsubsection{Bootloader / Gestores de arranque definicion}
\label{sec:orgc2297c4}

\begin{enumerate}
\item GRUB
\label{sec:org33c7ab5}
GRUB (GNU GRand Unified Bootloader) es un \textbf{cargador de arranque}; es el programa que aparece al iniciar y se encarga de cargar el sistema operativo (o una ISO) y pasarle el control.
\item Windows boot manager
\label{sec:org25bc2bd}

\item Secure boot
\label{sec:orgdd4736b}

MOK database
\item Ventoy
\label{sec:orgd7690b0}

Ventoy es una herramienta que nos permite poder arrancar varias imágenes ISO desde una misma memoria USB. Se instala sobre la memoria USB, y recursivamente busca las imágenes ISO que contenga para mostrarlas en el menú de arranque. Se nos queda de tarea para la próxima semana traer una memoria USB con Ventoy instalado.

\begin{center}
\includegraphics[width=.9\linewidth]{./ventoy_boot.jpg}
\end{center}


\begin{itemize}
\item \textbf{Ventoy y su GRUB:} Ventoy no usa exactamente el mismo GRUB que el del sistema instalado; incluye y arranca con su propia varainte de \textbf{GRUB2} para poder gestionar el menú y el arranque de múltiples ISOs desde una sola USB.

\item \textbf{Consola de GRUB en Ventoy:} En el menú de Ventoy/GRUB, al presionar la tecla \texttt{C} se abre la \textbf{consola} (tipo terminal) de GRUB.
\begin{itemize}
\item En esta consola podemos inspeccionar y explorar qué ve el bootloader (discos/particiones/archivos) y consultar variables o configuración.
\item Comandos:
\begin{verbatim}
        ls
        help
        set
        ls (hd0,gpt1)/
        cat (hd0,gpt1)/boot/grub/grub.cfg
\end{verbatim}
\item Esto sirve para tipo depurar, inspeccionar por qué algo no arranca como debe, confirmar rutas, o entender cómo Ventoy/GRUB está resolviendo la configuración.
\end{itemize}
\end{itemize}
\end{enumerate}
\subsection{Conceptos de repaso}
\label{sec:orga0e5f2f}
\begin{itemize}
\item \textbf{Proceso de arranque (boot process):}
Secuencia general: BIOS/UEFI → bootloader (GRUB) → kernel → init/systemd.
Punto clave: el sistema operativo \textbf{no existe} mientras estamos en GRUB; solo existe firmware con bootloader.

\item \textbf{Bootloader vs Kernel:}
GRUB no es el sistema operativo ni el kernel.
Su única responsabilidad es localizar, cargar el kernel (y el initramfs) en memoria y cederle el control.
No ejecuta procesos ni gestiona recursos del sistema.

\item \textbf{Separación de responsabilidades:}
Ventoy delega completamente el arranque a GRUB y evita modificar el disco.
Ejemplo de buen diseño: cada componente hace una sola cosa bien definida.

\item \textbf{Acceso a disco antes del kernel:}
GRUB puede leer sistemas de archivos (FAT, EXT, ISO) sin drivers del kernel.

\item \textbf{Lectura de archivos sin montaje:}
El bootloader accede directamente a estructuras del sistema de archivos.
Montar un FS es una abstracción que pertenece al kernel, no al bootloader.
\end{itemize}
\subsection{Máximas}
\label{sec:orgd9c41ec}

\subsubsection{Todo es un archivo}
\label{sec:org3855184}
En los sistemas derivados de Unix, como Linux
\subsection{Sección libre}
\label{sec:orgd82fac6}

\begin{itemize}
\item El comando ls nos permite listar los contenidos del directorio en el que nos encontramos actualmente. Usando los parámetros -la, podemos colocarlos en forma de lista y mostrar archivos ocultos para tener una vista más general y completa del directorio. Por ejemplo:
\end{itemize}

\begin{verbatim}
ls -la
\end{verbatim}

\phantomsection
\label{}
\begin{verbatim}
total 448
drwxr-xr-x 1 mrtaichi mrtaichi    158 Feb 18 21:46 .
drwxr-xr-x 1 mrtaichi mrtaichi    186 Feb 18 21:37 ..
-rw-r--r-- 1 mrtaichi mrtaichi  23480 Feb 18 21:53 bitacora1.org
-rw-r--r-- 1 mrtaichi mrtaichi 249738 Feb 18 21:46 bitacora1.pdf
-rw-r--r-- 1 mrtaichi mrtaichi  29531 Feb 18 21:46 bitacora1.tex
-rw-r--r-- 1 mrtaichi mrtaichi   9900 Feb 18 21:06 bitacora2.org
drwxr-xr-x 1 mrtaichi mrtaichi    166 Feb 18 21:53 .git
-rw-r--r-- 1 mrtaichi mrtaichi     25 Feb 18 21:46 test.txt
-rw-r--r-- 1 mrtaichi mrtaichi 133687 Feb  7 12:15 ventoy_boot.jpg
\end{verbatim}

\begin{itemize}
\item Existen dos formas de referenciar un archivo en Linux: Mediante su ruta relativa y mediante su ruta absoluta. Generalmente una ruta relativa empieza por un ./ o ../, mientras que una ruta absoluta empieza por /, ya que es la ruta completa al archivo desde la raíz del sistema de archivos. Por ejemplo:
\end{itemize}

\begin{verbatim}
echo este es el mismo archivo > test.txt
cat /home/mrtaichi/Documents/escuela/adminUnix/test.txt # Ruta absoluta
cat ./test.txt # Ruta relativa
\end{verbatim}

\phantomsection
\label{}
\begin{verbatim}
este es el mismo archivo
\end{verbatim}


\noindent\rule{\textwidth}{0.5pt}
\section{Disponibilidad del sistema: RAID y puntos únicos de falla}
\label{sec:org40e6394}

\subsection{Conceptos nuevos}
\label{sec:org238d3da}
\subsubsection{Alta disponibilidad}
\label{sec:org9dcd8c1}

\subsubsection{Redundancia}
\label{sec:orgaad9502}

Concepto estrechamente relacionado con Punto único de falla. Es la respuesta directa a solucionar este problema. Siempre existe un componente listo para tomar el lugar y mantener el sistema funcionando.
\subsubsection{Tolerancia a fallos}
\label{sec:org89c3da5}
\subsubsection{Punto único de falla (Single Point of Failure)}
\label{sec:orgadf53d8}

Cuando una de las partes del sistema es tan crítica que su fallo puede arriesgar la integridad de todo el sistema.
\subsubsection{Técnicas de Protección de datos}
\label{sec:orgf120f46}
\begin{enumerate}
\item Replicación
\label{sec:orge482c4f}
\item Paridad
\label{sec:org93bcc02}
\item Backups vs redundancia
\label{sec:org9d68b1c}
\end{enumerate}
\subsubsection{RAID (Redundant Array of Independent Disks)}
\label{sec:org402284a}
\begin{enumerate}
\item Concepto general
\label{sec:org821f0f4}
\item Objetivos: rendimiento vs seguridad
\label{sec:org336ab50}
\item RAID por hardware vs RAID por software
\label{sec:orgee6ebd9}
\item Niveles de RAID
\label{sec:orgebad62f}
\begin{enumerate}
\item RAID 0
\label{sec:orgbd23f9a}
\item RAID 1
\label{sec:org33b8cb4}
\item RAID 5
\label{sec:orgaaa66ac}
\item RAID 6
\label{sec:org6785562}
\item RAID 10
\label{sec:orgba44c1d}
\end{enumerate}
\end{enumerate}
\subsection{Conceptos de repaso}
\label{sec:orgf6bdd60}

\begin{itemize}
\item \textbf{Proceso de arranque:} La disponibilidad del sistema empieza desde el encendido; si falla el firmware, el bootloader o el kernel, no hay sistema. RAID protege la capa de almacenamiento donde viven los datos.
\item \textbf{Sistemas de archivos:} GRUB puede leer sistemas de archivos (FAT, EXT, ISO) en disco; los datos que la redundancia protege residen en particiones y FS.
\item \textbf{Todo es un archivo:} Máxima ya vista en GRUB; los dispositivos que RAID agrupa se representan como archivos en /dev.
\end{itemize}
\subsection{Máximas}
\label{sec:orgbf0d7bd}

\subsubsection{Todos los Linux son iguales}
\label{sec:org2854004}
En cualquier distribución de Linux podemos -a final de cuentas- hacer cualquier cosa. Todas funcionan esencialmente para lo mismo, y aunque evidentemente hay diferencias, se puede trabajar con ellas sin problema.
\subsection{Sección libre}
\label{sec:org0b54a4f}

\begin{itemize}
\item Estuvimos hablando de la importancia de la redundancia para preservar la información. Como ejemplo usamos el sistema RAID, que utiliza varios discos duros para crear replicación de información y tolerancia a fallos.
\item Generalmente la emulación es más lenta que la virtualización. El primer sistema de WSL usaba emulación de Linux, ahora el segundo utiliza virtualización.
\item Distrowatch es un sitio web en el que se pueden observar todas las distribuciones de Linux y muchos datos acerca de ellas, incluyendo un ranking de cuáles son las distros más usadas.
\item SCSI (que se pronuncia ``scuzzy'') es una interfaz de intercambio de datos que se utiliza sobre todo en servidores y computadoras de alto desempeño. Hablando del sistema RAID, es generalmente sobre esta interfaz sobre la que se construyen varios controladores RAID que están en la industria.
\end{itemize}

\noindent\rule{\textwidth}{0.5pt}
\section{De Unix a GNU/Linux: Origen, Filosofía y Evolución del Software Libre}
\label{sec:org0d8c8f1}
\subsection{Conceptos nuevos}
\label{sec:org4489763}

\subsubsection{Origen y evolución de Unix}
\label{sec:orgc2154f2}

\begin{enumerate}
\item Contexto académico
\label{sec:org90edd8d}

\item Nacimiento de Unix (1969)
\label{sec:org6073da2}

Unix nace en 1969 como un sistema operativo desarrollado en Bell Labs, al principio con fines académicos y distribuido para varias universidades. De ahí nace BSD cuando se vuelve comercial.
\item BSD
\label{sec:org42baac5}

Berkeley System Distribution. Nace como un Unix con código fuente original de Unix. De el nacen distribuciones todavía vivas hasta el día de hoy.
\item Linus Torvalds
\label{sec:org3435ffa}
\end{enumerate}
\subsubsection{Sistema Unix-like}
\label{sec:org9a7fa07}

\begin{enumerate}
\item Diferencia entre Unix y Unix-like
\label{sec:org8b4e96f}
Un sistema Unix es aquel que usa código fuente de Unix. Un Unix-like es aquel que está hecho para comportarse como Unix pero no usa código de Unix. Linux es Unix-like
\end{enumerate}
\subsubsection{Filosofía Unix (simplicidad, modularidad, herramientas pequeñas que hacen una sola cosa)}
\label{sec:org3a4d290}

\subsubsection{Proyecto GNU}
\label{sec:orga80fef4}

\begin{enumerate}
\item Filosofía del software libre
\label{sec:org41b225d}

\item Herramientas GNU (gcc, bash, coreutils)
\label{sec:orgfe2673c}

\item Licencia GPL
\label{sec:org61e13a7}
\end{enumerate}
\subsubsection{GNU/Linux como sistema completo}
\label{sec:orgb335f8f}

\begin{enumerate}
\item Integración del kernel Linux con herramientas GNU
\label{sec:org9ffb4fd}

\item Concepto de distribución (Ubuntu, Debian, etc.)
\label{sec:orgfd31df8}
\end{enumerate}
\subsubsection{Comercialización de Unix}
\label{sec:orga60af60}

\begin{enumerate}
\item Versiones propietarias
\label{sec:org334d08c}

\item Impacto en la industria
\label{sec:org440f670}
\end{enumerate}
\subsection{Conceptos de repaso}
\label{sec:org7047fef}

\begin{itemize}
\item \textbf{Kernel:} En GRUB vimos que el bootloader carga el kernel; aquí vemos el origen de ese kernel (Linux, Linus Torvalds) y su integración con GNU.
\item \textbf{Distribuciones:} Ya mencionadas al hablar de elegir distro (Información general) y en RAID (Distrowatch, “todos los Linux son iguales”).
\item \textbf{Filosofía de una sola cosa:} En GRUB repasamos la separación de responsabilidades (Ventoy, GRUB); la filosofía Unix (herramientas pequeñas que hacen una cosa) es la misma idea.
\end{itemize}
\subsection{Máximas}
\label{sec:orgf03519b}

\subsection{Sección libre}
\label{sec:orge9117bd}

\noindent\rule{\textwidth}{0.5pt}
\section{Kernel}
\label{sec:org45d97c3}

\subsection{Conceptos nuevos}
\label{sec:org66a65d6}

\subsubsection{Definición de kernel}
\label{sec:org058af97}
\begin{enumerate}
\item Intermediario entre hardware y software
\label{sec:org5484bd0}
\end{enumerate}
\subsubsection{Rol del kernel}
\label{sec:org6d6fb7d}
\begin{enumerate}
\item Gestión de CPU, memoria y dispositivos
\label{sec:orga61c22d}
\item Planificación (scheduling)
\label{sec:orgaa458d8}
\item Gestión de memoria
\label{sec:orgdd1dc6b}
\item Control de dispositivos
\label{sec:org43237a3}
\item Manejo de interrupciones
\label{sec:orgb8564d6}
\end{enumerate}
\subsubsection{Llamadas al sistema (System Calls)}
\label{sec:org81d568c}
\begin{enumerate}
\item Interfaz entre espacio de usuario y kernel
\label{sec:org3f35a32}
\item Ejemplos: fork(), exec(), read(), write()
\label{sec:orgd6d6e01}
\item Cambio de modo usuario a modo kernel
\label{sec:orga7c1e98}
\end{enumerate}
\subsubsection{Espacio de usuario vs espacio de kernel}
\label{sec:org97c009f}
\begin{enumerate}
\item Separación de privilegios
\label{sec:org02d0c38}
\item Seguridad y protección del sistema
\label{sec:org410acf4}
\end{enumerate}
\subsection{Conceptos de repaso}
\label{sec:org1a924bd}

\begin{itemize}
\item \textbf{Proceso de arranque:} En GRUB vimos la secuencia BIOS/UEFI → bootloader → \textbf{kernel} → init/systemd; aquí estudiamos qué es ese kernel que se carga y qué hace.
\item \textbf{Linux como kernel:} En “De Unix a GNU/Linux” vimos que Linux es el kernel y GNU las herramientas de usuario; el kernel es el intermediario entre ambas capas.
\end{itemize}
\subsection{Máximas}
\label{sec:orgb49ba50}

\subsection{Sección libre}
\label{sec:org8d18c52}

\noindent\rule{\textwidth}{0.5pt}
\section{Modelo de Ejecución y Gestión de Procesos en Linux}
\label{sec:org85d6306}

\subsection{Conceptos nuevos}
\label{sec:org0e8bf04}
\begin{itemize}
\item Programa vs Proceso
\begin{itemize}
\item Definición de programa
\item Definición de proceso
\item Ciclo de vida de un proceso
\end{itemize}

\item Procesos y Tareas en Linux
\begin{itemize}
\item Qué es una tarea (task)
\item Concepto de hilo (thread)
\item Diferencia entre proceso e hilo (thread)
\item Identificador de proceso (PID)
\item Estados de un proceso (running, ready, waiting, stopped, zombie)
\end{itemize}

\item Representación Interna de Procesos en Linux
\begin{itemize}
\item struct task\textsubscript{struct}
\begin{itemize}
\item Estructura que representa un proceso en el kernel
\item Contiene:
\begin{itemize}
\item PID
\item Estado
\item Prioridad
\item Información básica de memoria
\end{itemize}
\end{itemize}
\end{itemize}

\item Qué es el scheduler
\begin{itemize}
\item Asignación de CPU a procesos
\item Cambio de contexto (context switch)
\item Procesos con mayor o menor prioridad
\item Tiempo de CPU compartido
\item sched.h (visión general)
\begin{itemize}
\item Definición de políticas de planificación
\item Constantes relacionadas con scheduling
\item Interacción con task\textsubscript{struct}
\end{itemize}
\end{itemize}

\item Comandos útiles
\begin{itemize}
\item pstree
\item nohup
\end{itemize}
\end{itemize}
\subsection{Conceptos de repaso}
\label{sec:org2e062c8}
\begin{itemize}
\item Espacio de Usuario vs Espacio de Kernel
\begin{itemize}
\item Separación de privilegios
\item Protección de memoria
\item Cambio de modo (user mode ↔ kernel mode)
\end{itemize}

\item System Calls (Llamadas al Sistema)
\begin{itemize}
\item Mecanismo para que un proceso solicite servicios al kernel
\item Interfaz entre usuario y kernel
\item Cambio de contexto
\item Ejemplos comunes de syscalls: fork(), exec(), wait(), read(), write(), open(), exit()
\end{itemize}
\end{itemize}


\begin{itemize}
\item Flujo básico de una system call
\begin{itemize}
\item Interrupción o instrucción especial (syscall/sysenter)
\item El proceso solicita un servicio
\item El CPU cambia a modo kernel
\item El kernel ejecuta la operación
\item Se regresa al modo usuario
\end{itemize}
\end{itemize}
\subsection{Máximas}
\label{sec:org1a6f705}

\subsection{Sección libre}
\label{sec:org1c2b1e4}

\begin{itemize}
\item Un proceso es un programa que se está ejecutando en el sistema y constantemente le está pidiendo recursos al kernel. Los procesos se comunican con el kernel a través de syscalls.

\item Linux tiene un directorio llamado /tmp el cual es volátil. Ahí se guardan archivos necesarios para el funcionamiento de programas y SO durante la sesión, pero que no es necesario conservar y por lo tanto se pueden borrar en el siguiente apagado. En Windows existe la misma implementación en una carpeta llamada Temp.

\item \textbf{nohup} nos permite ejecutar procesos y evitar que mueran cuando el padre muere (ignora señales de hangup). Para guardar la salida en un archivo: \texttt{nohup COMANDO > FILE}.

\item \textbf{pstree} muestra un árbol de los procesos en ejecución, dando una vista clara de las relaciones de parentesco. De ahí se observa que el proceso del que nacen todos los procesos en espacio de usuario es systemd.
\end{itemize}

\begin{verbatim}
pstree
\end{verbatim}

\phantomsection
\label{}
\begin{verbatim}
systemd-+-NetworkManager---3*[{NetworkManager}]
        |-ananicy-cpp---3*[{ananicy-cpp}]
        |-avahi-daemon---avahi-daemon
        |-bluetoothd
        |-chrome_crashpad---2*[{chrome_crashpad}]
        |-containerd---12*[{containerd}]
        |-containerd-shim-+-postgres---5*[postgres]
        |                 `-10*[{containerd-shim}]
        |-containerd-shim-+-s6-svscan-+-s6-supervise---gitea---9*[{gitea}]
        |                 |           `-s6-supervise---sshd
        |                 `-10*[{containerd-shim}]
        |-containerd-shim-+-bash-+-/opt/lampp/bin/---6*[/opt/lampp/bin/]
        |                 |      |-mysqld_safe---mysqld---29*[{mysqld}]
        |                 |      |-proftpd
        |                 |      |-sshd
        |                 |      `-tail
        |                 `-10*[{containerd-shim}]
        |-2*[containerd-shim-+-mysqld---36*[{mysqld}]]
        |                    `-10*[{containerd-shim}]]
        |-containerd-shim-+-apache2---5*[apache2]
        |                 `-10*[{containerd-shim}]
        |-dbus-broker-lau---dbus-broker
        |-dockerd-+-4*[docker-proxy---6*[{docker-proxy}]]
        |         |-6*[docker-proxy---7*[{docker-proxy}]]
        |         |-2*[docker-proxy---8*[{docker-proxy}]]
        |         `-36*[{dockerd}]
        |-electron-+-electron---electron---16*[{electron}]
        |          |-electron---electron---electron---10*[{electron}]
        |          |-electron---7*[{electron}]
        |          |-electron-+-electron---11*[{electron}]
        |          |          `-23*[{electron}]
        |          |-2*[electron---18*[{electron}]]
        |          |-electron---20*[{electron}]
        |          |-electron-+-zsh
        |          |          `-19*[{electron}]
        |          `-37*[{electron}]
        |-emacs-+-bash---pstree
        |       |-bwrap---bwrap---glycin-svg---3*[{glycin-svg}]
        |       `-9*[{emacs}]
        |-ksecretd
        |-msedge-+-2*[cat]
        |        |-msedge---msedge---20*[{msedge}]
        |        |-msedge---msedge-+-msedge---7*[{msedge}]
        |        |                 |-6*[msedge---10*[{msedge}]]
        |        |                 |-msedge---12*[{msedge}]
        |        |                 |-3*[msedge---9*[{msedge}]]
        |        |                 |-msedge---25*[{msedge}]
        |        |                 |-msedge---14*[{msedge}]
        |        |                 `-msedge---8*[{msedge}]
        |        |-2*[msedge---8*[{msedge}]]
        |        `-51*[{msedge}]
        |-msedge_crashpad---2*[{msedge_crashpad}]
        |-msedge_crashpad---{msedge_crashpad}
        |-netbird---8*[{netbird}]
        |-polkitd---3*[{polkitd}]
        |-power-profiles----3*[{power-profiles-}]
        |-rtkit-daemon---2*[{rtkit-daemon}]
        |-sddm-+-sddm-helper---start-hyprland-+-Hyprland-+-Xwayland---4*[{Xwayland}]
        |      |                              |          |-alacritty-+-zsh
        |      |                              |          |           `-9*[{alacritty}]
        |      |                              |          |-hyprpaper---13*[{hyprpaper}]
        |      |                              |          |-waybar---37*[{waybar}]
        |      |                              |          `-14*[{Hyprland}]
        |      |                              `-{start-hyprland}
        |      `-{sddm}
        |-spotify-+-spotify---spotify---15*[{spotify}]
        |         |-spotify-+-spotify---7*[{spotify}]
        |         |         `-spotify---12*[{spotify}]
        |         |-spotify---8*[{spotify}]
        |         `-63*[{spotify}]
        |-systemd-+-(sd-pam)
        |         |-at-spi-bus-laun-+-dbus-broker-lau---dbus-broker
        |         |                 `-4*[{at-spi-bus-laun}]
        |         |-at-spi2-registr---3*[{at-spi2-registr}]
        |         |-dbus-broker-lau---dbus-broker
        |         |-dconf-service---3*[{dconf-service}]
        |         |-pipewire---2*[{pipewire}]
        |         |-pipewire-pulse---2*[{pipewire-pulse}]
        |         |-wireplumber---5*[{wireplumber}]
        |         |-xdg-desktop-por---6*[{xdg-desktop-por}]
        |         |-xdg-desktop-por---7*[{xdg-desktop-por}]
        |         |-xdg-desktop-por---4*[{xdg-desktop-por}]
        |         |-xdg-document-po-+-fusermount3
        |         |                 `-7*[{xdg-document-po}]
        |         `-xdg-permission----3*[{xdg-permission-}]
        |-systemd-journal
        |-systemd-logind
        |-systemd-resolve
        |-systemd-timesyn---{systemd-timesyn}
        |-systemd-udevd
        |-systemd-userdbd---3*[systemd-userwor]
        |-upowerd---3*[{upowerd}]
        `-wpa_supplicant
\end{verbatim}

Para entender mejor el funcionamiento de un proceso, se puede revisar el código fuente del kernel Linux. El término usado en el kernel para referirse a los procesos es una \textbf{task} (tarea), ya que la misma estructura sirve para procesos y para hilos. La estructura es \texttt{task\_struct}, declarada en \texttt{include/linux/sched.h}. Contiene, entre otras cosas: estado (\_\textsubscript{state}), PID y TGID, prioridades (prio, static\textsubscript{prio}), relaciones (parent, children, sibling), memoria (mm), archivos abiertos (files), credenciales (cred) y manejo de señales (signal, sighand). El proceso más importante y del que nacen todos los procesos en espacio de usuario es systemd.

\noindent\rule{\textwidth}{0.5pt}
\section{Arquitectura de almacenamiento físico y su representación en Linux}
\label{sec:orgd93c73d}

\subsection{Conceptos nuevos}
\label{sec:org02241c9}

\subsubsection{Dispositivos de almacenamiento}
\label{sec:orgea502c8}
\begin{itemize}
\item HDD vs SSD
\item NVMe vs SATA
\item Rendimiento, latencia e IOPS
\item Persistencia vs volatilidad
\end{itemize}
\subsubsection{Representación en Linux}
\label{sec:orgee08281}
\begin{itemize}
\item Dispositivos en /dev (/dev/sda, /dev/sdb, /dev/nvme0n1)
\item Concepto de block device
\item Uso de lsblk y blkid
\end{itemize}
\subsubsection{Interfaces de comunicación de discos}
\label{sec:org3bf2167}
\begin{itemize}
\item SCSI
\item SAS (Serial Attached SCSI)
\item SATA (Serial ATA)
\item NVMe (Non-Volatile Memory Express)
\end{itemize}
\subsubsection{Particiones}
\label{sec:org0bdaa7a}
\begin{itemize}
\item ¿Qué es una partición?
\item División lógica del disco
\item Independencia de particiones
\item Concepto de sector y bloque
\end{itemize}
\subsubsection{Tablas de partición}
\label{sec:orgd1fbe3a}
\begin{itemize}
\item MBR (Master Boot Record)
\item GPT (GUID Partition Table)
\item Diferencias técnicas (límite 2TB, número de particiones, redundancia)
\end{itemize}
\subsubsection{Tipos de particiones (MBR)}
\label{sec:org9324377}
\begin{itemize}
\item Primaria
\item Extendida
\item Lógica
\end{itemize}
\subsubsection{Herramientas de particionado}
\label{sec:org6b4b7e1}
\begin{itemize}
\item fdisk, cfdisk, parted, gparted
\end{itemize}
\subsection{Conceptos de repaso}
\label{sec:org0fcce31}

\begin{itemize}
\item \textbf{GRUB y discos:} En la consola de GRUB vimos \texttt{(hd0,gpt1)}, discos y particiones; la EFI System Partition; el bootloader ya “ve” discos y tablas de partición (GPT).
\item \textbf{Tablas de partición:} GPT apareció en el arranque (partición EFI); aquí se ven MBR y GPT con detalle (límites, número de particiones).
\item \textbf{Todo es un archivo:} Los dispositivos se representan como archivos en /dev (máxima en GRUB); aquí vemos /dev/sda, /dev/nvme0n1, etc.
\item \textbf{RAID:} En disponibilidad vimos varios discos independientes; aquí cómo se representan esos discos en Linux (block devices, lsblk).
\end{itemize}
\subsection{Máximas}
\label{sec:org66fc91a}

\subsection{Sección libre}
\label{sec:org43dbd8f}

\begin{itemize}
\item Gparted es una herramienta con interfaz gráfica para crear y modificar particiones en un disco.
\item En Linux, \ref{sec:org3855184}. La carpeta /dev guarda representaciones en archivo de todos los dispositivos conectados (almacenamiento, terminales, pseudoterminales).
\end{itemize}

\noindent\rule{\textwidth}{0.5pt}
\section{Estructura lógica y administración de sistemas de archivos}
\label{sec:org2ce3f61}

\subsection{Conceptos nuevos}
\label{sec:orgdd803d4}

\subsubsection{¿Qué es un sistema de archivos?}
\label{sec:orgdb090c9}
\begin{itemize}
\item Organización lógica de datos
\item Relación con particiones
\item Abstracción sobre el hardware
\end{itemize}
\subsubsection{Sistemas de archivos comunes en Linux}
\label{sec:orgc03abce}
\begin{itemize}
\item ext4, xfs, btrfs, vfat, ntfs
\end{itemize}
\subsubsection{Estructura interna básica}
\label{sec:orgd4173fe}
\begin{itemize}
\item Superbloque
\item Inodos
\item Bloques de datos
\item Journaling
\item Metadatos
\end{itemize}
\subsubsection{Creación y formateo de particiones}
\label{sec:org0263097}
\begin{itemize}
\item mkfs, mkfs.ext4, mkfs.xfs
\item Verificación con fsck
\end{itemize}
\subsubsection{Montaje}
\label{sec:org23520a6}
\begin{itemize}
\item mount, umount
\item Puntos de montaje (/mnt, /media)
\item Montaje temporal vs permanente
\end{itemize}
\subsubsection{Archivo /etc/fstab}
\label{sec:org7fc873e}
\begin{itemize}
\item Montaje automático al inicio
\item UUID vs nombre de dispositivo
\item Opciones comunes (defaults, noatime, ro, rw)
\end{itemize}
\subsection{Conceptos de repaso}
\label{sec:orgcba5469}

\begin{itemize}
\item \textbf{GRUB y sistemas de archivos:} GRUB puede leer sistemas de archivos (FAT, EXT, ISO) sin montar; el bootloader accede a estructuras del FS. Montar es una abstracción del \textbf{kernel}, no del bootloader.
\item \textbf{Particiones y almacenamiento:} Un sistema de archivos va sobre particiones; ya vimos /dev, block devices, particionado y tablas (MBR/GPT) en el capítulo anterior.
\item \textbf{Kernel:} El kernel es quien monta y gestiona los FS; las syscalls (read, write, open) operan sobre archivos una vez montado el FS.
\end{itemize}
\subsection{Máximas}
\label{sec:orgaffcd07}

\subsection{Sección libre}
\label{sec:orgd22c1b4}

\noindent\rule{\textwidth}{0.5pt}
\section{Permisos y Propiedad}
\label{sec:org48a31f1}

\subsection{Conceptos nuevos}
\label{sec:org57966c1}

\subsubsection{Permisos básicos}
\label{sec:org604d734}
\begin{itemize}
\item Lectura (r), Escritura (w), Ejecución (x)
\item Comando para ver permisos: \texttt{ls -la}
\end{itemize}
\subsubsection{Usuarios y grupos}
\label{sec:orgc9cc098}
\begin{itemize}
\item Propietario, Grupo, Otros
\item Comandos: chmod, chown, chgrp
\end{itemize}
\subsection{Conceptos de repaso}
\label{sec:orge2b806f}

\begin{itemize}
\item \textbf{\texttt{ls -la}:} Ya usado en GRUB (Sección libre) para listar en forma de lista y mostrar archivos ocultos; la misma salida muestra permisos (r/w/x) y propietario/grupo.
\item \textbf{Rutas y archivos:} En GRUB vimos rutas absolutas y relativas para referenciar archivos; aquí quién (qué usuario/grupo) puede acceder a cada archivo.
\item \textbf{Sistema de archivos:} Los archivos tienen metadatos (inodos, etc.); propiedad y permisos son parte de esa información que el FS guarda.
\item \textbf{Procesos y kernel:} En \texttt{task\_struct} vimos \texttt{cred} (credenciales); el kernel usa UID/GID del proceso para comprobar permisos en cada acceso.
\end{itemize}
\subsection{Máximas}
\label{sec:orgfe50bb6}

\subsection{Sección libre}
\label{sec:org397cf52}
\end{document}
